
<h3>Section 2. Compensation</h3>
<p>MAH agrees to pay the Representative for services provided under this Agreement as outlined in Addendum A below.</p>

<h3>Section 3. Relationships of the Parties</h3>
<p>The Representative shall be considered an independent Contractor and is not an employee, partner, or joint venturer of MAH. Consistent with the foregoing, MAH shall not deduct withholding taxes, social security taxes, or any other taxes or fees required to be deducted by an employer from Representative's compensation.</p>

<h3>Section 4. Term of Engagement</h3>
<p>This Agreement will become effective upon electronic signature and will continue until Terminated under Section 16 below.</p>

<h3>Section 5. Responsibilities of the Representative</h3>
<p>The Representative shall have complete control over the time spent, the manner, and the disposition of the services provided. The Representative agrees to devote sufficient time and energy to fulfill the spirit and purpose of this Agreement.</p>

<h3>Section 6. Responsibilities of MAH</h3>
<p>MAH agrees to follow all reasonable requests of the Representative necessary to the performance of the Representative's duties under this Agreement. MAH agrees to provide the Representative with such information, marketing materials, customer relationship management (CRM) software, and other software as may be necessary to facilitate the efficient flow of business between the Parties.</p>

<h3>Section 7. Representations and Warranties</h3>
<p>Representative expressly represents and warrants that he/she is over the age of 18 and has the authority to enter into this Agreement.</p>

<h3>Section 8-11. [Standard Provisions]</h3>
<p>Waiver, Compliance, Representative's Employees, and Liability provisions apply as standard.</p>

<h3>Section 12. Confidentiality</h3>
<p>The Representative agrees that all proprietary knowledge and information shall be regarded as strictly confidential and held in confidence solely for MAH's benefit and use.</p>

<h3>Section 13. Non-Competition</h3>
<p>Representative agrees not to contact or initiate contact at any time for any purpose, either directly or indirectly, with any MAH referral without prior written consent.</p>

<h3>Section 14. Non-Solicitation and Non-Circumvention</h3>
<p>Neither Party will solicit or hire any Employee, Consultant, Customer, Referral, Client, Strategic Partner, or Service Provider of the other Party for a period of one year following termination.</p>

<h3>Section 15. Indemnity</h3>
<p>The Representative shall indemnify and hold MAH free and harmless from any obligations, debts, suits, costs, claims, judgments, liabilities, attorneys' fees, liens, and attachments.</p>

<h3>Section 16. Termination of Agreement</h3>
<p>Either Party may terminate this Agreement at any time, with or without cause, provided the Terminating Party provides 30-day prior written notice. All commissions owed shall survive the termination of this Agreement.</p>

<h3>Section 17-28. [Standard Legal Provisions]</h3>
<p>Partial Invalidity, Entire Agreement, Assignment, Counterparts, Acknowledgment, Notices, Governing Law (Commonwealth of Virginia), Attorney's Fees, Arbitration, Force Majeure, Amendment, and Headings provisions apply as standard.</p>

<hr/>

<h2>ADDENDUM A - TIERED SALES STRUCTURE COMPENSATION</h2>

<p>With respect to the Products/Services, the following Commission Structures will apply:</p>

<table border="1" cellpadding="8" style="width:100%; border-collapse: collapse;">
  <tr style="background-color: #f0f0f0;"><th>Role</th><th>Commission Rate</th></tr>
  <tr><td><strong>Primary Referral Agent (Top Rep)</strong></td><td>75% of Net Vendor/Client Claim Fee (NVCCF)</td></tr>
  <tr><td>Level One Referral Partner</td><td>10% of NVCCF</td></tr>
  <tr><td>Level Two Referral Partner</td><td>10% of NVCCF</td></tr>
  <tr><td>Level Three Referral Partner</td><td>5% of NVCCF</td></tr>
</table>

<p><em>Note: Tiers are static and not compressed. Breakage rolls up to the Company (MAH).</em></p>

<h3>Commission Payment Process</h3>
<ul>
  <li>Active Representatives will be paid by the 15th of the month for funds received by MAH in the preceding month for Net Sales of Paid Invoices on Accounts generated by the Representative.</li>
  <li>Representative will provide ACH account information to be paid electronically by MAH.</li>
</ul>

<h3>Definitions</h3>
<ul>
  <li><strong>Commission Entitlement:</strong> The Active Representative shall be entitled to receive a "Commission" on "Net Sales" of fully "Paid Invoices" from "Active Accounts".</li>
  <li><strong>Client:</strong> Any business account, individual, group, organization, or entity to whom the Products or Services are marketed, solicited, sold, or purchased.</li>
  <li><strong>Net Sales of Paid Invoices:</strong> Amounts specified by MAH's generated invoices issued in any month, less taxes, refunds, credits, returns, rebates, discounts, shipping costs, adjustments, and bad debts.</li>
</ul>

<p style="margin-top: 30px;"><strong>By signing below, you acknowledge that you have read, understand, and agree to be bound by this Agreement.</strong></p>`
      });
      
      res.status(201).json({ success: true, template: mahContract });
    } catch (error) {
      console.error("Error seeding MAH contract:", error);
      res.status(500).json({ message: "Failed to seed contract template" });
    }
  });

  // Seed all MAH service contracts
  app.post("/api/contracts/seed-all-services", async (req, res) => {
    try {
      const existing = await storage.getAllContractTemplates();
      const results: any[] = [];

      // Define all MAH services from the BSBA contract structure
      const services = [
        { name: "Private Reinsurance eR3", grossPct: 70, description: "Private Reinsurance Program - eR3" },
        { name: "Private Reinsurance eR2", grossPct: 70, description: "Private Reinsurance Program - eR2" },
        { name: "Tax Resolution Services", grossPct: 55, description: "Legacy Tax & Resolution Services - Tier One" },
        { name: "FICA Tips Tax Credit", grossPct: 70, description: "FICA Tips Tax Credit Recovery" },
        { name: "Tax Recovery", grossPct: 70, description: "Tax Recovery Services" },
        { name: "ICC Logistics", grossPct: 18, description: "ICC Logistics Revenue Sharing" },
      ];

      for (const svc of services) {
        const exists = existing.find(t => t.serviceName === svc.name);
        if (exists) {
          results.push({ service: svc.name, status: "exists", id: exists.id });
          continue;
        }

        const contract = await storage.createContractTemplate({
          name: `${svc.name} Revenue Sharing Agreement`,
          version: "1.0",
          companyName: "MISSION ACT HEALTH, INC.",
          requiredFor: "affiliate",
          isActive: "true",
          contractType: "service",
          grossCommissionPct: svc.grossPct,
          serviceName: svc.name,
          content: `<h1>${svc.name.toUpperCase()} REVENUE SHARING AGREEMENT</h1>

<p>This Revenue Sharing Agreement ("Agreement") is between <strong>MISSION ACT HEALTH, INC.</strong>, a Virginia corporation ("MAH"), and the undersigned Independent Representative ("Representative").</p>

<h2>SERVICE DESCRIPTION</h2>
<p>${svc.description}</p>

<h2>COMPENSATION</h2>
<p>Compensation payable to the Representative network shall be governed by Schedule A.</p>

<p><strong>Gross Commission Rate: ${svc.grossPct}%</strong></p>

<p>The ${svc.grossPct}% gross commission shall be distributed according to the Schedule A compensation structure based on the Representative's position within the MAH network:</p>

<table border="1" cellpadding="8" style="width:100%; border-collapse: collapse;">
  <tr style="background-color: #f0f0f0;"><th>Recipient</th><th>Rate</th></tr>
  <tr><td><strong>Producer (You)</strong></td><td>69% base + compression from empty uplines</td></tr>
  <tr><td>Each Upline (max 6)</td><td>1% each</td></tr>
  <tr><td>House (MAH)</td><td>22.5%</td></tr>
  <tr><td>Recruiter Bounty</td><td>2.5%</td></tr>
</table>

<p><strong>Compression:</strong> Empty upline levels compress TO THE PRODUCER. A solo producer with no uplines receives 75% (69% + 6%).</p>

<h2>TERM AND TERMINATION</h2>
<p>This Agreement will commence upon its execution and continue until terminated by either party with 30 days prior written notice.</p>

<h2>RELATIONSHIP OF PARTIES</h2>
<p>The Representative is an independent contractor, not an employee, partner, or joint venturer of MAH.</p>

<h2>GOVERNING LAW</h2>
<p>This Agreement will be governed by the laws of the Commonwealth of Virginia.</p>

<hr/>

<p><strong>By signing below, you acknowledge that you have read, understand, and agree to be bound by this Agreement and the attached Schedule A.</strong></p>`
        });

        results.push({ service: svc.name, status: "created", id: contract.id });
      }

      res.status(201).json({ success: true, results });
    } catch (error) {
      console.error("Error seeding service contracts:", error);
      res.status(500).json({ message: "Failed to seed service contracts" });
    }
  });

  // Seed ICC Logistics service contract (legacy endpoint)
  app.post("/api/contracts/seed-icc", async (req, res) => {
    try {
      const existing = await storage.getAllContractTemplates();
      const iccExists = existing.find(t => t.serviceName === "ICC Logistics");
      if (iccExists) {
        return res.json({ message: "ICC Logistics contract already exists", id: iccExists.id });
      }

      const iccContract = await storage.createContractTemplate({
        name: "ICC Logistics Revenue Sharing Agreement",
        version: "1.0",
        companyName: "MISSION ACT HEALTH, INC.",
        requiredFor: "affiliate",
        isActive: "true",
        contractType: "service",
        grossCommissionPct: 18,
        serviceName: "ICC Logistics",
        content: `<h1>REVENUE SHARING AGREEMENT</h1>

<p>This Revenue Sharing Agreement ("Agreement") is between <strong>MISSION ACT HEALTH, Inc.</strong>, a Virginia corporation ("MAH"), on behalf of services rendered by <strong>ICC LOGISTICS, INC</strong> ("ICC"), a New York corporation, and the undersigned Referral Agent.</p>

<h2>RECITALS</h2>
<p>MISSION ACT HEALTH, LLC is the Master Agent and will have the responsibility of paying all commissions due to the Referral Agent five (5) days from receipt of funds from ICC.</p>

<h2>OBJECTIVES</h2>
<p>ICC and Referral Agent both have expertise in business consulting services and wish to enter into an arrangement whereby Referral Agent will introduce to ICC certain customers and prospects in return for a share of the revenues generated from business arising as a result of those introductions.</p>

<h2>RELATIONSHIP OF PARTIES</h2>
<p>In the performance of this Agreement, the parties will at all times remain independent legal entities and operate as independent contractors, and not the other party's partner or joint venturer.</p>

<h2>CONFIDENTIALITY</h2>
<p>The identity of any prospects or customers introduced by one party to the other shall remain confidential and shall not be disclosed to any other person or entity.</p>

<h2>TERM AND TERMINATION</h2>
<p>This Agreement will commence upon its execution and continue until the expiration of all projects governed under this Agreement. Either party may terminate this Agreement at any time upon 30 days prior written notice.</p>

<h2>COMPENSATION</h2>
<p>Compensation payable to the Referral Agent network shall be governed by Schedule A.</p>

<p><strong>Base Commission Rate:</strong></p>
<ul>
  <li><strong>All Other Services (excluding Audit):</strong> 18% of ICC's gross revenue</li>
  <li><strong>Audit Services:</strong> 5% of ICC's net revenue</li>
</ul>

<p>The 18% gross commission shall be distributed according to the Schedule A compensation structure based on the Referral Agent's position within the MAH network:</p>

<table border="1" cellpadding="8" style="width:100%; border-collapse: collapse;">
  <tr style="background-color: #f0f0f0;"><th>Recipient</th><th>Rate</th></tr>
  <tr><td><strong>Producer (You)</strong></td><td>69% base + compression from empty uplines</td></tr>
  <tr><td>Each Upline (max 6)</td><td>1% each</td></tr>
  <tr><td>House</td><td>22.5%</td></tr>
  <tr><td>Recruiter Bounty</td><td>2.5%</td></tr>
</table>

<p><strong>Compression:</strong> Empty upline levels compress to the Producer. A solo producer with no uplines receives 75% (69% + 6%).</p>

<h2>APPLICABLE LAW</h2>
<p>This Agreement will be interpreted in accordance with the laws of the State of New York.</p>

<h2>ARBITRATION</h2>
<p>Any disputes arising out of this Agreement will be settled by binding arbitration in accordance with the Commercial Arbitration Rules of the American Arbitration Association.</p>

<hr/>

<p><strong>By signing below, you acknowledge that you have read, understand, and agree to be bound by this Agreement and the attached Schedule A.</strong></p>`
      });

      res.status(201).json({ success: true, template: iccContract });
    } catch (error) {
      console.error("Error seeding ICC contract:", error);
      res.status(500).json({ message: "Failed to seed ICC contract template" });
    }
  });

  // Get all contract templates
  app.get("/api/contracts/templates", async (req, res) => {
    try {
      const templates = await storage.getAllContractTemplates();
      res.json(templates);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch templates" });
    }
  });

  // Get active contract templates
  app.get("/api/contracts/templates/active", async (req, res) => {
    try {
      const templates = await storage.getActiveContractTemplates();
      res.json(templates);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch templates" });
    }
  });

  // Get a single contract template
  app.get("/api/contracts/templates/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const template = await storage.getContractTemplate(id);
      if (!template) {
        return res.status(404).json({ message: "Template not found" });
      }
      res.json(template);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch template" });
    }
  });

  // Create contract template (admin only)
  app.post("/api/contracts/templates", requireAdmin, async (req, res) => {
    try {
      const data = insertContractTemplateSchema.parse(req.body);
      const template = await storage.createContractTemplate(data);
      res.status(201).json(template);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create template" });
    }
  });

  // Update contract template (admin only)
  app.patch("/api/contracts/templates/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateContractTemplate(id, req.body);
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update template" });
    }
  });

  // Get all signed agreements (admin/master)
  app.get("/api/contracts/signed", requireAdmin, async (req, res) => {
    try {
      const agreements = await storage.getAllSignedAgreements();
      res.json(agreements);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch agreements" });
    }
  });

  // Get signed agreements for a specific affiliate
  app.get("/api/contracts/signed/affiliate/:affiliateId", requireAuth, async (req, res) => {
    try {
      const affiliateId = parseInt(req.params.affiliateId);
      const agreements = await storage.getSignedAgreementsByAffiliate(affiliateId);
      res.json(agreements);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch agreements" });
    }
  });

  // Check if affiliate has signed a specific contract
  app.get("/api/contracts/check/:affiliateId/:templateId", requireAuth, async (req, res) => {
    try {
      const affiliateId = parseInt(req.params.affiliateId);
      const templateId = parseInt(req.params.templateId);
      const hasSigned = await storage.hasAffiliateSignedContract(affiliateId, templateId);
      res.json({ hasSigned });
    } catch (error) {
      res.status(500).json({ message: "Failed to check signature" });
    }
  });

  // Sign a contract
  app.post("/api/contracts/sign", requireAuth, async (req, res) => {
    try {
      const data = insertSignedAgreementSchema.parse(req.body);
      const clientIp = req.headers['x-forwarded-for'] || req.socket.remoteAddress;
      const signedAgreement = await storage.createSignedAgreement({
        ...data,
        signedIpAddress: Array.isArray(clientIp) ? clientIp[0] : clientIp || 'unknown'
      });
      res.status(201).json({ success: true, id: signedAgreement.id });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      console.error("Contract signing error:", error);
      res.status(500).json({ message: "Failed to sign contract" });
    }
  });

  // Get pending contracts for an affiliate (contracts they haven't signed yet)
  app.get("/api/contracts/pending/:affiliateId", requireAuth, async (req, res) => {
    try {
      const affiliateId = parseInt(req.params.affiliateId);
      const allTemplates = await storage.getActiveContractTemplates();
      const signedAgreements = await storage.getSignedAgreementsByAffiliate(affiliateId);
      const signedTemplateIds = signedAgreements.map(sa => sa.contractTemplateId);
      const pendingTemplates = allTemplates.filter(t => !signedTemplateIds.includes(t.id));
      res.json(pendingTemplates);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch pending contracts" });
    }
  });

  // Get signed agreements for the current logged-in user
  app.get("/api/contracts/my-signed", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.json([]);
      }
      const signedAgreements = await storage.getSignedAgreementsByAffiliate(req.session.userId);
      res.json(signedAgreements);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch signed agreements" });
    }
  });

  // ===== COMMISSION CALCULATION API =====

  // Calculate commission breakdown for a sale
  app.post("/api/commission/calculate", async (req, res) => {
    try {
      const { grossRevenue, recruiterExists = true, l2Active = true, l3Active = true, l4Active = true, l5Active = true } = req.body;
      
      const gross = Math.max(0, Number(grossRevenue) || 0);
      
      const pct = {
        recruiter: 0.025,
        l1: 0.67,
        l2: 0.035,
        l3: 0.020,
        l4: 0.012,
        l5: 0.008,
        l6: 0.005,
      };

      const recruiterPay = recruiterExists ? Math.round(gross * pct.recruiter * 100) : 0;
      const l1Pay = Math.round(gross * pct.l1 * 100);
      
      const l2Base = Math.round(gross * pct.l2 * 100);
      const l3Base = Math.round(gross * pct.l3 * 100);
      const l4Base = Math.round(gross * pct.l4 * 100);
      const l5Base = Math.round(gross * pct.l5 * 100);
      const l6Base = Math.round(gross * pct.l6 * 100);

      const l2Pay = l2Active ? l2Base : 0;
      const l3Pay = l3Active ? l3Base : 0;
      const l4Pay = l4Active ? l4Base : 0;
      const l5Pay = l5Active ? l5Base : 0;

      const compressedToL6 =
        (l2Active ? 0 : l2Base) +
        (l3Active ? 0 : l3Base) +
        (l4Active ? 0 : l4Base) +
        (l5Active ? 0 : l5Base);

      const l6Pay = l6Base + compressedToL6;

      res.json({
        grossRevenue: gross,
        grossRevenueCents: Math.round(gross * 100),
        recruiterBounty: recruiterPay,
        l1Commission: l1Pay,
        l2Commission: l2Pay,
        l3Commission: l3Pay,
        l4Commission: l4Pay,
        l5Commission: l5Pay,
        l6Commission: l6Pay,
        compressedToL6: compressedToL6,
        totalPaid: recruiterPay + l1Pay + l2Pay + l3Pay + l4Pay + l5Pay + l6Pay,
        houseAllocation: l1Pay + l2Pay + l3Pay + l4Pay + l5Pay + l6Pay,
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to calculate commissions" });
    }
  });

  // Get commission configuration (simplified model)
  app.get("/api/commission/config", async (req, res) => {
    try {
      const config = await storage.getActiveCommissionConfig();
      if (!config) {
        // Return simplified defaults
        res.json({
          producerBasePct: 69,
          uplinePctEach: 1,
          maxUplineLevels: 6,
          housePct: 22.5,
          recruiterBountyPct: 2.5,
        });
      } else {
        res.json({
          producerBasePct: config.producerBasePct,
          uplinePctEach: config.uplinePctEach,
          maxUplineLevels: config.maxUplineLevels,
          housePct: config.housePct,
          recruiterBountyPct: config.recruiterBountyPct,
        });
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to get commission config" });
    }
  });

  // Seed default commission config (simplified model)
  app.post("/api/commission/seed", requireAdmin, async (req, res) => {
    try {
      const existing = await storage.getActiveCommissionConfig();
      if (existing) {
        return res.json({ success: true, message: "Config already exists", config: existing });
      }
      const config = await storage.createCommissionConfig({
        name: "default",
        producerBasePct: 69,
        uplinePctEach: 1,
        maxUplineLevels: 6,
        housePct: 22.5,
        recruiterBountyPct: 2.5,
        isActive: "true",
      });
      res.json({ success: true, config });
    } catch (error) {
      res.status(500).json({ message: "Failed to seed commission config" });
    }
  });

  // === Business Leads API ===
  
  // Public: Submit a business lead
  app.post("/api/business-leads", async (req, res) => {
    try {
      const { referralCode, ...rest } = req.body;
      const data = insertBusinessLeadSchema.parse(rest);
      
      // Get client IP address
      const clientIp = req.headers['x-forwarded-for']?.toString().split(',')[0] || req.socket.remoteAddress || 'unknown';
      
      // Look up affiliate by referral code if provided, or check IP tracking
      let referredById: number | undefined;
      let finalReferralCode = referralCode;
      
      if (referralCode) {
        // Referral code provided - use it and track IP
        const affiliate = await storage.getUserByReferralCode(referralCode);
        if (affiliate) {
          referredById = affiliate.id;
          // Track this IP if not already tracked
          const existingIpTracking = await storage.getActiveIpReferral(clientIp);
          if (!existingIpTracking) {
            const expiresAt = new Date();
            expiresAt.setDate(expiresAt.getDate() + 30); // 30 day expiration
            await storage.createIpReferralTracking({
              ipAddress: clientIp,
              affiliateId: affiliate.id,
              referralCode: referralCode,
              expiresAt,
            });
          }
        }
      } else {
        // No referral code - check if IP is already tracked
        const ipTracking = await storage.getActiveIpReferral(clientIp);
        if (ipTracking && ipTracking.affiliateId) {
          referredById = ipTracking.affiliateId;
          finalReferralCode = ipTracking.referralCode;
        }
      }
      
      const lead = await storage.createBusinessLead({
        ...data,
        referralCode: finalReferralCode || undefined,
        referredBy: referredById,
      } as any);
      res.status(201).json({ success: true, lead });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      console.error("Error creating business lead:", error);
      res.status(500).json({ message: "Failed to submit business lead" });
    }
  });

  // Admin/Master: Get all business leads
  app.get("/api/admin/business-leads", requireAdmin, async (req, res) => {
    try {
      const leads = await storage.getAllBusinessLeads();
      res.json(leads);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch business leads" });
    }
  });

  // Master portal: Get all business leads (for master users)
  app.get("/api/master/business-leads", async (req, res) => {
    try {
      const leads = await storage.getAllBusinessLeads();
      res.json(leads);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch business leads" });
    }
  });

  // Affiliate: Get business leads referred by this affiliate
  app.get("/api/affiliate/business-leads", requireAffiliate, async (req, res) => {
    try {
      const leads = await storage.getBusinessLeadsByReferrer(req.session.userId!);
      res.json(leads);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch business leads" });
    }
  });

  // Admin: Update business lead
  app.patch("/api/admin/business-leads/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateBusinessLead(id, req.body);
      if (!updated) {
        return res.status(404).json({ message: "Lead not found" });
      }
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update business lead" });
    }
  });

  // === Security Tracking API ===

  // Master portal: Get all IP referral tracking with enriched data
  app.get("/api/master/security-tracking", requireAdmin, async (req, res) => {
    try {
      const ipReferrals = await storage.getAllIpReferrals();
      const allAffiliates = await storage.getAllAffiliates();
      const allNdas = await storage.getAllAffiliateNdas();
      const allHelpRequests = await storage.getAllHelpRequests();
      const allBusinessLeads = await storage.getAllBusinessLeads();
      
      // Enrich each IP tracking record with affiliate info, NDA status, and conversion status
      const enrichedData = await Promise.all(ipReferrals.map(async (tracking: any) => {
        const affiliate = allAffiliates.find((a: any) => a.id === tracking.affiliateId);
        const now = new Date();
        const isActive = tracking.expiresAt > now;
        
        // Check if this IP has any submissions (help requests or business leads)
        // This shows if they "became a lead"
        const hasHelpRequest = allHelpRequests.some(hr => hr.referredBy === tracking.affiliateId);
        const hasBusinessLead = allBusinessLeads.some(bl => bl.referredBy === tracking.affiliateId);
        
        return {
          id: tracking.id,
          ipAddress: tracking.ipAddress,
          referralCode: tracking.referralCode,
          affiliateId: tracking.affiliateId,
          affiliateName: affiliate?.name || 'Unknown',
          affiliateEmail: affiliate?.email || 'Unknown',
          expiresAt: tracking.expiresAt,
          createdAt: tracking.createdAt,
          isActive,
          clicked: true, // If we have a record, they clicked
          hasConvertedToLead: hasHelpRequest || hasBusinessLead,
        };
      }));
      
      // Also get affiliate list with their NDA status
      const affiliatesWithNdaStatus = allAffiliates
        .filter((a: any) => a.role === 'affiliate' || a.role === 'submaster')
        .map((affiliate: any) => {
          const hasSignedNda = allNdas.some(nda => nda.userId === affiliate.id);
          const referralCount = ipReferrals.filter(r => r.affiliateId === affiliate.id).length;
          return {
            id: affiliate.id,
            name: affiliate.name,
            email: affiliate.email,
            role: affiliate.role,
            referralCode: affiliate.referralCode,
            hasSignedNda,
            referralCount,
            createdAt: affiliate.createdAt,
          };
        });
      
      res.json({
        ipTracking: enrichedData,
        affiliates: affiliatesWithNdaStatus,
        totalTrackedIPs: ipReferrals.length,
        activeTracking: enrichedData.filter(d => d.isActive).length,
      });
    } catch (error) {
      console.error("Error fetching security tracking:", error);
      res.status(500).json({ message: "Failed to fetch security tracking data" });
    }
  });

  // Affiliate: Get their own IP referral tracking
  app.get("/api/affiliate/security-tracking", requireAffiliate, async (req, res) => {
    try {
      const ipReferrals = await storage.getIpReferralsByAffiliate(req.session.userId!);
      const now = new Date();
      const allHelpRequests = await storage.getHelpRequestsByAssignee(req.session.userId!);
      const allBusinessLeads = await storage.getBusinessLeadsByReferrer(req.session.userId!);
      
      // Check if user has signed NDA
      const hasSignedNda = await storage.hasAffiliateSignedNda(req.session.userId!);
      
      const enrichedData = ipReferrals.map(tracking => {
        const isActive = tracking.expiresAt > now;
        return {
          id: tracking.id,
          ipAddress: tracking.ipAddress,
          referralCode: tracking.referralCode,
          expiresAt: tracking.expiresAt,
          createdAt: tracking.createdAt,
          isActive,
          clicked: true,
        };
      });
      
      res.json({
        ipTracking: enrichedData,
        totalTrackedIPs: ipReferrals.length,
        activeTracking: enrichedData.filter(d => d.isActive).length,
        totalLeadsConverted: allHelpRequests.length + allBusinessLeads.length,
        hasSignedNda,
      });
    } catch (error) {
      console.error("Error fetching affiliate security tracking:", error);
      res.status(500).json({ message: "Failed to fetch security tracking data" });
    }
  });

  // =====================================================
  // STRESS TEST SIMULATION API
  // =====================================================
  
  // Run stress test simulation with 1000 sales across 30 affiliates
  // Public endpoint for demo purposes
  app.post("/api/stress-test/run", async (req, res) => {
    try {
      // Get configurable parameters from request body
      const { 
        numSales = 1000, 
        numAffiliates = 30, 
        hierarchyRandomness = 50 
      } = req.body;
      
      // Validate and clamp values
      const salesCount = Math.min(Math.max(1, numSales), 5000);
      const affiliateCount = Math.min(Math.max(5, numAffiliates), 100);
      const randomness = Math.min(Math.max(0, hierarchyRandomness), 100) / 100;
      
      const militaryRanks = ["E1", "E2", "E3", "E4", "E5", "E6", "E7"];
      const firstNames = ["James", "Michael", "Robert", "John", "David", "William", "Richard", "Joseph", "Thomas", "Charles", "Christopher", "Daniel", "Matthew", "Anthony", "Mark", "Donald", "Steven", "Andrew", "Paul", "Joshua", "Kenneth", "Kevin", "Brian", "George", "Timothy"];
      const lastNames = ["Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller", "Davis", "Rodriguez", "Martinez", "Hernandez", "Lopez", "Gonzalez", "Wilson", "Anderson", "Thomas", "Taylor", "Moore", "Jackson", "Martin", "Lee", "Perez", "Thompson", "White", "Harris"];
      const roles = ["master", "sub_master", "affiliate", "affiliate", "affiliate", "affiliate", "affiliate"];
      const categories = ["disability", "holistic", "healthcare", "insurance", "tax_credits", "b2b", "b2c"];
      const statuses = ["pending", "approved", "paid"];
      
      // Step 1: Create test opportunities if none exist
      let existingOpportunities = await storage.getAllOpportunities();
      if (existingOpportunities.length === 0) {
        const testOpportunities = [
          { name: "VA Disability Claim", category: "disability", description: "VA Disability assistance", commissionType: "percentage", commissionL1: 6900, commissionL2: 100, commissionL3: 100, commissionL4: 100, commissionL5: 100, commissionL6: 100, commissionL7: 2250, isActive: "true" },
          { name: "Holistic Health Program", category: "holistic", description: "Holistic veteran health", commissionType: "percentage", commissionL1: 6900, commissionL2: 100, commissionL3: 100, commissionL4: 100, commissionL5: 100, commissionL6: 100, commissionL7: 2250, isActive: "true" },
          { name: "Tax Credit Services", category: "tax_credits", description: "Business tax credit", commissionType: "flat", commissionL1: 50000, commissionL2: 2000, commissionL3: 2000, commissionL4: 2000, commissionL5: 2000, commissionL6: 2000, commissionL7: 15000, isActive: "true" },
          { name: "Insurance Package", category: "insurance", description: "Veteran insurance", commissionType: "percentage", commissionL1: 6900, commissionL2: 100, commissionL3: 100, commissionL4: 100, commissionL5: 100, commissionL6: 100, commissionL7: 2250, isActive: "true" },
        ];
        for (const opp of testOpportunities) {
          await storage.createOpportunity(opp);
        }
        existingOpportunities = await storage.getAllOpportunities();
      }
      
      // Step 2: Check for existing stress test affiliates or create new ones
      const allAffiliates = await storage.getAllVltAffiliates();
      let stressTestAffiliates = allAffiliates.filter(a => a.email.includes("@stresstest.nav"));
      
      // If we have existing stress test affiliates, use them; otherwise create new ones
      if (stressTestAffiliates.length === 0) {
        const hashedPassword = await hashPassword("TestPass123!");
        const subMasterCount = Math.max(1, Math.floor(affiliateCount * 0.15)); // 15% are sub_masters
        const createdAffiliates: any[] = [];
        
        for (let i = 0; i < affiliateCount; i++) {
          const firstName = firstNames[Math.floor(Math.random() * firstNames.length)];
          const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
          const rank = militaryRanks[Math.floor(Math.random() * militaryRanks.length)];
          const role = i === 0 ? "master" : (i < subMasterCount ? "sub_master" : "affiliate");
          
          // Build hierarchy with configurable randomness
          const getRandomParent = (maxIdx: number) => {
            if (maxIdx <= 0) return null;
            const structuredIdx = Math.min(i - 1, maxIdx - 1);
            const randomIdx = Math.floor(Math.random() * maxIdx);
            const blendedIdx = Math.round(structuredIdx * (1 - randomness) + randomIdx * randomness);
            return createdAffiliates[Math.min(blendedIdx, maxIdx - 1)]?.id || null;
          };
          
          const level1Id = i > 0 ? getRandomParent(Math.min(i, subMasterCount + 2)) : null;
          const level2Id = i > 1 ? getRandomParent(Math.min(i, subMasterCount)) : null;
          const level3Id = i > 2 ? getRandomParent(Math.min(i, Math.max(2, subMasterCount - 1))) : null;
          const level4Id = i > 3 ? getRandomParent(Math.min(i, 3)) : null;
          const level5Id = i > 4 ? getRandomParent(2) : null;
          const level6Id = createdAffiliates[0]?.id || null;
          
          try {
            const affiliate = await storage.createVltAffiliate({
              name: `${rank} ${firstName} ${lastName}`,
              email: `test.${firstName.toLowerCase()}.${lastName.toLowerCase()}.${i}@stresstest.nav`,
              phone: `555-${String(Math.floor(Math.random() * 900) + 100)}-${String(Math.floor(Math.random() * 9000) + 1000)}`,
              passwordHash: hashedPassword,
              referralCode: `STRESS${i.toString().padStart(3, "0")}`,
              role,
              level1Id,
              level2Id,
              level3Id,
              level4Id,
              level5Id,
              level6Id,
              level7Id: null,
              recruiterId: i > 0 ? createdAffiliates[Math.floor(Math.random() * i)].id : null,
              status: "active",
              isCompActive: Math.random() > 0.2 ? "true" : "false",
              totalSales: 0,
              totalCommissions: 0,
              totalRecruiterBounties: 0,
            });
            createdAffiliates.push(affiliate);
          } catch (e) {
            console.log(`Skipping duplicate affiliate ${i}`);
          }
        }
        stressTestAffiliates = createdAffiliates;
      }
      
      // Step 3: Create sales with commissions (using salesCount)
      const salesCreated: any[] = [];
      const commissionsCreated: any[] = [];
      
      // Use stress test affiliates for sales
      if (stressTestAffiliates.length === 0) {
        return res.status(400).json({ message: "No affiliates available for stress test. Please clear data and try again." });
      }
      
