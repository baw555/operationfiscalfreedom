The core rule (lock this in)

A feature failing must never block progress unless it is legally or logically required.

Thatâ€™s it. Everything flows from this.

For the NDA flow, the only hard requirement is:

a valid NDA submission (signature + required fields)

Everything else (camera, upload, previews, helpers) is assistive, not authoritative.

The correct mental model

Each panel answers one question:

â“ Is this capability available right now?

â“ If not, is there an allowed fallback?

The page does not ask:

â€œDid everything succeed?â€

It asks:

â€œDo I have the minimum required evidence to proceed?â€

Step 1 â€” Define REQUIRED vs OPTIONAL explicitly

Do this once, in writing (or code comments):

âœ… REQUIRED (hard gate)

NDA legal text accepted

Signature captured by any valid method

Required form fields valid

ğŸŸ¡ OPTIONAL (soft gate)

Camera-based signature

ID upload

Preview generation

Any assistive automation

If an optional feature fails â†’ warn, degrade, continue.

Step 2 â€” Represent capability state (simple, powerful)

In your affiliate-nda-context.tsx, add capability flags, not booleans like â€œerrorâ€.

Example:

type CapabilityStatus = "available" | "unavailable" | "degraded";

interface NdaCapabilities {
  camera: CapabilityStatus;
  upload: CapabilityStatus;
}


Each panel sets its own status:

setCapabilities((c) => ({
  ...c,
  camera: "unavailable",
}));


No global â€œfailedâ€ flag.

Step 3 â€” Panels must never block submission
âŒ Bad (what causes dead ends)
if (!cameraReady) {
  return <Error />;
}

âœ… Correct
if (cameraUnavailable) {
  return (
    <Warning>
      Camera unavailable. You may continue using typed signature.
    </Warning>
  );
}


The panel communicates, not controls.

Step 4 â€” Submission logic checks only REQUIRED inputs

Your submit button logic should look like this (conceptually):

const canSubmit =
  hasAcceptedLegalText &&
  hasValidSignature &&
  formIsValid;


âŒ No checks for:

camera success

upload success

preview success

Those may add evidence, but they do not block progress.

Step 5 â€” Make degradation visible but non-blocking

This is critical for trust.

Example UI copy (simple and honest):

âš ï¸ Camera access is unavailable.
You can still complete the NDA using a typed signature.

Or:

â„¹ï¸ ID upload failed.
You may continue, and weâ€™ll request it later if required.

No scary language. No red stop signs.

Step 6 â€” Log degraded submissions (for ops, not UX)

Behind the scenes, tag the submission:

degradedCapabilities: {
  camera: "unavailable",
  upload: "available",
}


This lets you:

audit later

follow up if needed

improve tooling

But never surface this as a blocker to the user.

Step 7 â€” Why this is legally and operationally safe

This is important.

You are not weakening compliance because:

the legal artifact (NDA + signature) is intact

the user intent is recorded

optional evidence is clearly marked as unavailable, not missing

Courts and auditors care about:

intent

acknowledgment

integrity

Not whether a webcam worked.

What this buys you immediately

Affiliates are never stuck

Hardware failures donâ€™t kill conversions

Support tickets drop

You stop debugging edge-case browsers

The system behaves like a real platform, not a demo

One sentence to enforce everywhere

Optional features may fail loudly; required steps may never fail silently.

Youâ€™ve already built the structure that makes this easy â€” this is just using it correctly.