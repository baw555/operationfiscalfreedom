Alright â€” switching fully into architect mode.
Iâ€™m going to stress-test Phase 2 as if this were about to be rolled into a regulated, revenue-producing system, then Iâ€™ll tell you what questions must be asked, what is safe, what is unsafe, and what must be explicitly decided before moving on.

I will not add new fixes yet unless something is genuinely unsafe.

ARCHITECT STRESS TEST â€” PHASE 2 (FRONTEND STABILITY LAYER)

You did the right thing by stopping here and asking for a stress test. This phase is foundational â€” mistakes here propagate everywhere.

Weâ€™ll evaluate each decision, then run edge-case simulations.

PART A â€” CANONICAL QUERY KEYS (queryKeys.ts)
What you proposed
export const qk = {
  me: ["auth", "me"] as const,
  ndaStatus: ["affiliate", "ndaStatus"] as const,
  scheduleAStatus: ["affiliate", "scheduleAStatus"] as const,
};

Architect verdict

âœ… Correct
âœ… Safe
âœ… Necessary
ğŸŸ¡ Incomplete but intentionally so

Stress test scenarios
Scenario 1 â€” Mixed adoption (current reality)

Some pages still use ["/api/auth/me"]

Some use ["auth"]

Some will start using qk.me

Result:
âœ” No runtime breakage
âœ” No crashes
âŒ Cache invalidation is still fragmented (expected)

Architect ruling:
This is acceptable because you explicitly said â€œfoundation firstâ€.
The existence of queryKeys.ts does not change behavior yet â€” it creates a single truth anchor.

This is correct sequencing.

Scenario 2 â€” Future migration

Once pages migrate to qk.me, you can:

invalidate auth state once

reason about auth as one cache identity

This solves the exact bug identified in the UI audit:

affiliate-apply invalidates /api/auth/me, affiliate-dashboard listens on ["auth"] â†’ stale auth state

Architect ruling:
This file is pure upside, no risk.

What NOT to do yet

âŒ Do not delete old queryKeys
âŒ Do not mass-replace pages yet
âŒ Do not enforce lint rules yet

This stays inert until Phase 3+.

PART B â€” SAFE API WRAPPER (api.ts)
What you proposed
export async function api<T>(url: string): Promise<T> {
  const res = await fetch(url, { credentials: "include" });

  const isJson = res.headers
    .get("content-type")
    ?.includes("application/json");

  const body = isJson ? await res.json().catch(() => null) : null;

  if (!res.ok) {
    throw new ApiError(res.status, body?.message || res.statusText);
  }

  return body as T;
}


This is the most important part to stress-test.

STRESS TEST MATRIX â€” api()

Weâ€™ll run it through every failure mode the frontend can experience.

1ï¸âƒ£ 401 Unauthorized (MOST COMMON)

Example

GET /api/auth/me
401 Unauthorized
Content-Type: application/json
{ "message": "Not authenticated" }


Behavior

res.ok === false

body.message extracted

throws ApiError(401, "Not authenticated")

React effect

Error is thrown

But now it is a typed error, not a null return

Page can:

catch

redirect

show login

or boundary-handle

Architect verdict:
âœ… This fixes the blank screen bug
âœ… This is exactly what you want
âš  Requires pages to intentionally handle 401 (later)

2ï¸âƒ£ 401 with EMPTY BODY (common with middleware)

Example

401 Unauthorized
Content-Type: application/json
(empty body)


Behavior

res.json() throws

.catch(() => null) â†’ body = null

error message falls back to res.statusText

Architect verdict:
âœ… Safe
âœ… No crash
âœ… Predictable message

3ï¸âƒ£ Non-JSON error response (HTML / text)

Example

500 Internal Server Error
Content-Type: text/html
<html>...</html>


Behavior

isJson === false

body = null

error thrown with statusText

Architect verdict:
âœ… Safe
âœ… No JSON parsing crash
âš  You lose server error details (this is good for security)

4ï¸âƒ£ 204 No Content (common for PATCH/DELETE)

Example

204 No Content


Behavior

isJson === false

body = null

res.ok === true

returns null as T

Architect verdict:
ğŸŸ¡ Acceptable if documented

Important nuance:
This is the one place where api<T>() can legitimately return null.

Architect rule:

GETs should never be 204

Mutations already use apiRequest()

As long as you do not use api() for mutations, this is safe.

5ï¸âƒ£ Network failure / CORS / offline

Example

DNS failure

Replit hiccup

Browser offline

Behavior

fetch() throws before res

error is not an ApiError

Architect verdict:
ğŸŸ¡ This will bubble as an untyped error
ğŸŸ¢ This is OK for now

Why?

Network errors should still surface

You will later decide whether to:

retry

show offline UI

degrade gracefully

Do not over-handle this yet.

6ï¸âƒ£ Pages that still use getQueryFn()

Current reality:

useQuery({ queryKey: ["/api/auth/me"], queryFn: getQueryFn() })


These will:

still throw raw errors

still blank-screen if mishandled

Architect verdict:
âœ… This is acceptable because you explicitly are not converting pages yet

This phase is foundational, not corrective.

PART C â€” COEXISTENCE WITH EXISTING INFRASTRUCTURE
Coexists with:

apiRequest() (mutations)

getQueryFn() (legacy GETs)

raw fetch() (legacy pages)

Architect verdict:
âœ… No conflicts
âœ… No runtime overlap
âœ… No naming collision
âœ… No behavior regression

PART D â€” WHAT IS NOT SOLVED YET (INTENTIONALLY)

This phase does NOT yet solve:

âŒ Role gating drift
âŒ NDA gate duplication
âŒ Query invalidation mismatch
âŒ staleTime: Infinity inconsistencies
âŒ Admin pages using any
âŒ Commission logic in UI

That is correct.
Foundation â‰  migration.

CRITICAL ARCHITECT QUESTIONS (YOU MUST ANSWER THESE)

Before proceeding to Phase 3 (page migration), you must answer:

Q1 â€” How should 401 be handled globally?

Choose ONE (explicitly):

A) Redirect to login automatically

B) Let page decide (recommended)

C) Show inline auth error component

Architect recommendation: B
But this must be a conscious decision.

Q2 â€” Should api() ever be used for mutations?

If yes, it must:

accept method

accept body

handle 204s explicitly

If no (current plan):

enforce rule:
GET â†’ api()
MUTATE â†’ apiRequest()

Architect recommendation: No, keep split.

Q3 â€” Do you want to deprecate getQueryFn()?

Eventually you should â€” but not yet.

Decision needed:

Deprecate later

Or keep for static pages

Q4 â€” Do you want runtime response validation?

Examples:

Zod decode on frontend

Soft validation with warnings

No validation (status quo)

Architect note:
This is optional, but if chosen, it must integrate with api().

FINAL ARCHITECT RULING
Phase 2 is:

âœ… Structurally correct
âœ… Safe to merge
âœ… Non-breaking
âœ… The right abstraction boundary
âœ… Properly sequenced

Phase 2 is NOT:

âŒ A full fix
âŒ A migration
âŒ A behavior change

And thatâ€™s exactly what you want.