import { useState } from "react";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { 
  Shield, Users, FileText, FolderOpen, Eye, Download, ChevronRight, Camera, IdCard, 
  FileSignature, ClipboardCheck, Receipt, Link2, Store, CreditCard, Gift, LogIn,
  LayoutDashboard, ClipboardList, HelpCircle, DollarSign, Stethoscope, Globe, 
  Mail, Briefcase, TrendingUp, Building, Target, Heart, Truck, UserCheck, AlertCircle,
  Clock, CheckCircle, XCircle, Sofa, RefreshCw, FileDown
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";

const DataTable = ({ title, icon, data, columns, hideHeader }: { title: string; icon: React.ReactNode; data: any[]; columns: string[]; hideHeader?: boolean }) => (
  <div className="bg-black/20 rounded-lg border border-white/10 overflow-hidden" data-testid={`datatable-${title.toLowerCase().replace(/\s+/g, '-') || 'table'}`}>
    {!hideHeader && (
      <div className="p-4 border-b border-white/10">
        <h2 className="text-lg font-bold text-white flex items-center gap-2" data-testid={`datatable-title-${title.toLowerCase().replace(/\s+/g, '-')}`}>
          {icon}
          {title}
        </h2>
      </div>
    )}
    {data.length === 0 ? (
      <div className="p-8 text-center text-gray-400" data-testid="datatable-empty">No records found.</div>
    ) : (
      <div className="overflow-x-auto">
        <table className="w-full" data-testid="datatable-content">
          <thead className="bg-black/30">
            <tr>
              {columns.map((col) => (
                <th key={col} className="px-4 py-3 text-left text-xs font-bold text-gray-400 uppercase tracking-wider" data-testid={`header-${col}`}>
                  {col.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}
                </th>
              ))}
            </tr>
          </thead>
          <tbody className="divide-y divide-white/10" data-testid="datatable-body">
            {data.slice(0, 50).map((item: any, idx: number) => (
              <tr key={item.id || idx} className="hover:bg-white/5" data-testid={`row-${item.id || idx}`}>
                {columns.map((col) => (
                  <td key={col} className="px-4 py-3 text-sm text-gray-300" data-testid={`cell-${col}-${item.id || idx}`}>
                    {col === 'status' ? (
                      <span className={`px-2 py-1 rounded-full text-xs font-medium ${
                        item[col] === 'pending' || item[col] === 'new' ? 'bg-yellow-500/20 text-yellow-400' :
                        item[col] === 'approved' || item[col] === 'completed' || item[col] === 'converted' ? 'bg-green-500/20 text-green-400' :
                        item[col] === 'rejected' || item[col] === 'cancelled' ? 'bg-red-500/20 text-red-400' :
                        'bg-gray-500/20 text-gray-400'
                      }`} data-testid={`status-badge-${item.id || idx}`}>
                        {item[col] || 'pending'}
                      </span>
                    ) : col === 'createdAt' ? (
                      new Date(item[col]).toLocaleDateString()
                    ) : col === 'amount' ? (
                      `$${(item[col] || 0).toLocaleString()}`
                    ) : (
                      item[col] || '-'
                    )}
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
        {data.length > 50 && (
          <div className="p-3 text-center text-sm text-gray-400 border-t border-white/10" data-testid="datatable-pagination">
            Showing 50 of {data.length} records
          </div>
        )}
      </div>
    )}
  </div>
);

interface AffiliateFile {
  id: number;
  name: string;
  email: string;
  nda?: {
    id: number;
    fullName: string;
    address: string;
    facePhoto?: string;
    idPhoto?: string;
    signatureData?: string;
    signedAt: string;
  };
  contracts?: Array<{
    id: number;
    contractName: string;
    signedAt: string;
    signatureData?: string;
  }>;
  w9?: {
    name: string;
    address: string;
    city: string;
    state: string;
    zip: string;
    taxClassification: string;
    certificationDate: string;
  };
}

export default function MasterPortal() {
  const [, setLocation] = useLocation();
  const [selectedAffiliate, setSelectedAffiliate] = useState<AffiliateFile | null>(null);
  const [showDocumentViewer, setShowDocumentViewer] = useState(false);
  const [loginEmail, setLoginEmail] = useState("");
  const [loginPassword, setLoginPassword] = useState("");
  const [loginError, setLoginError] = useState("");
  const [isLoggingIn, setIsLoggingIn] = useState(false);
  const [pdfSecurityKey, setPdfSecurityKey] = useState("");
  const [pdfDownloadError, setPdfDownloadError] = useState("");
  const [isDownloadingPdf, setIsDownloadingPdf] = useState(false);
  const queryClient = useQueryClient();

  const downloadNdaPdf = async (ndaId: number, affiliateName: string) => {
    if (!pdfSecurityKey) {
      setPdfDownloadError("Please enter the security key");
      return;
    }
    
    setIsDownloadingPdf(true);
    setPdfDownloadError("");
    
    try {
      const res = await fetch(`/api/master/affiliate-nda-pdf/${ndaId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({ securityKey: pdfSecurityKey })
      });
      
      if (!res.ok) {
        const data = await res.json();
        setPdfDownloadError(data.message || "Failed to download PDF");
        return;
      }
      
      const blob = await res.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `NDA-${affiliateName.replace(/[^a-zA-Z0-9]/g, '_')}-${new Date().toISOString().split('T')[0]}.pdf`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
    } catch (err) {
      setPdfDownloadError("Network error - please try again");
    } finally {
      setIsDownloadingPdf(false);
    }
  };

  // Check if user is master admin - with retry logic for session timing
  const { data: authData, isLoading: authLoading } = useQuery({
    queryKey: ["/api/auth/me"],
    queryFn: async () => {
      const res = await fetch("/api/auth/me", { credentials: "include" });
      if (!res.ok) return null;
      return res.json();
    },
    retry: 6,
    retryDelay: 1000,
  });

  // Fetch all affiliates with their files
  const { data: affiliateFiles = [], isLoading: filesLoading, error: filesError } = useQuery<AffiliateFile[]>({
    queryKey: ["master-affiliate-files"],
    queryFn: async () => {
      const res = await fetch("/api/master/affiliate-files", { credentials: "include" });
      if (!res.ok) {
        const errorData = await res.json().catch(() => ({ message: "Unknown error" }));
        throw new Error(errorData.message || `HTTP ${res.status}`);
      }
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
    staleTime: 5 * 60 * 1000,
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });

  // Fetch finops referrals
  const { data: finopsReferrals = [], isLoading: referralsLoading } = useQuery<any[]>({
    queryKey: ["finops-referrals"],
    queryFn: async () => {
      const res = await fetch("/api/admin/finops-referrals", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch disability referrals
  const { data: disabilityReferrals = [], isLoading: disabilityLoading } = useQuery<any[]>({
    queryKey: ["disability-referrals"],
    queryFn: async () => {
      const res = await fetch("/api/admin/disability-referrals", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch vet professional intakes
  const { data: vetProfessionalIntakes = [], isLoading: vetProfessionalsLoading } = useQuery<any[]>({
    queryKey: ["vet-professional-intakes"],
    queryFn: async () => {
      const res = await fetch("/api/admin/vet-professional-intakes", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch healthcare intakes
  const { data: healthcareIntakes = [], isLoading: healthcareLoading } = useQuery<any[]>({
    queryKey: ["healthcare-intakes"],
    queryFn: async () => {
      const res = await fetch("/api/admin/healthcare-intakes", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch Schedule A signatures
  const { data: scheduleASignatures = [], isLoading: scheduleALoading } = useQuery<any[]>({
    queryKey: ["schedule-a-signatures"],
    queryFn: async () => {
      const res = await fetch("/api/admin/schedule-a-signatures", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch affiliate applications
  const { data: affiliateApplications = [] } = useQuery<any[]>({
    queryKey: ["affiliate-applications"],
    queryFn: async () => {
      const res = await fetch("/api/admin/affiliate-applications", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch help requests
  const { data: helpRequests = [] } = useQuery<any[]>({
    queryKey: ["help-requests"],
    queryFn: async () => {
      const res = await fetch("/api/admin/help-requests", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch startup grants
  const { data: startupGrants = [] } = useQuery<any[]>({
    queryKey: ["startup-grants"],
    queryFn: async () => {
      const res = await fetch("/api/admin/startup-grants", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch furniture assistance
  const { data: furnitureAssistance = [] } = useQuery<any[]>({
    queryKey: ["furniture-assistance"],
    queryFn: async () => {
      const res = await fetch("/api/admin/furniture-assistance", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch private doctor requests
  const { data: privateDoctorRequests = [] } = useQuery<any[]>({
    queryKey: ["private-doctor-requests"],
    queryFn: async () => {
      const res = await fetch("/api/admin/private-doctor-requests", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch website applications
  const { data: websiteApplications = [] } = useQuery<any[]>({
    queryKey: ["website-applications"],
    queryFn: async () => {
      const res = await fetch("/api/admin/website-applications", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch general contact
  const { data: generalContact = [] } = useQuery<any[]>({
    queryKey: ["general-contact"],
    queryFn: async () => {
      const res = await fetch("/api/admin/general-contact", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch veteran intakes
  const { data: veteranIntakes = [] } = useQuery<any[]>({
    queryKey: ["veteran-intakes"],
    queryFn: async () => {
      const res = await fetch("/api/admin/veteran-intakes", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch business intakes
  const { data: businessIntakes = [] } = useQuery<any[]>({
    queryKey: ["business-intakes"],
    queryFn: async () => {
      const res = await fetch("/api/admin/business-intakes", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch insurance intakes
  const { data: insuranceIntakes = [] } = useQuery<any[]>({
    queryKey: ["insurance-intakes"],
    queryFn: async () => {
      const res = await fetch("/api/admin/insurance-intakes", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch medical sales intakes
  const { data: medicalSalesIntakes = [] } = useQuery<any[]>({
    queryKey: ["medical-sales-intakes"],
    queryFn: async () => {
      const res = await fetch("/api/admin/medical-sales-intakes", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch business dev intakes
  const { data: businessDevIntakes = [] } = useQuery<any[]>({
    queryKey: ["business-dev-intakes"],
    queryFn: async () => {
      const res = await fetch("/api/admin/business-dev-intakes", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch business leads
  const { data: businessLeads = [] } = useQuery<any[]>({
    queryKey: ["business-leads"],
    queryFn: async () => {
      const res = await fetch("/api/admin/business-leads", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  // Fetch sales data
  const { data: salesData = [] } = useQuery<any[]>({
    queryKey: ["sales-data"],
    queryFn: async () => {
      const res = await fetch("/api/master/sales", { credentials: "include" });
      if (!res.ok) return [];
      return res.json();
    },
    enabled: authData?.user?.role === "admin" || authData?.user?.role === "master",
  });

  if (authLoading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-brand-navy to-slate-800 flex items-center justify-center">
        <div className="animate-spin w-8 h-8 border-4 border-white border-t-transparent rounded-full"></div>
      </div>
    );
  }

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoginError("");
    setIsLoggingIn(true);
    
    try {
      const res = await fetch("/api/auth/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({ email: loginEmail, password: loginPassword }),
      });
      
      const data = await res.json();
      
      if (!res.ok) {
        setLoginError(data.message || "Login failed");
        setIsLoggingIn(false);
        return;
      }
      
      if (data.user.role !== "admin" && data.user.role !== "master") {
        setLoginError("Access denied. Admin credentials required.");
        await fetch("/api/auth/logout", { method: "POST", credentials: "include" });
        setIsLoggingIn(false);
        return;
      }
      
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
    } catch {
      setLoginError("Connection error. Please try again.");
      setIsLoggingIn(false);
    }
  };

  // Access denied for non-admin/master users
  const isAuthorized = authData?.user?.role === "admin" || authData?.user?.role === "master";
  if (!authData || !isAuthorized) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-brand-navy to-slate-800 flex items-center justify-center p-4">
        <div className="w-full max-w-md">
          <div className="flex flex-col items-center gap-4 text-center mb-8">
            <div className="w-20 h-20 bg-brand-red rounded-full flex items-center justify-center">
              <Shield className="w-10 h-10 text-white" />
            </div>
            <div className="text-2xl text-white font-bold">MASTER PORTAL</div>
            <div className="text-gray-300">
              Enter your credentials to access the administration panel.
            </div>
          </div>
          
          <form onSubmit={handleLogin} className="bg-white/10 backdrop-blur-sm rounded-xl p-6 space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email" className="text-white">Email</Label>
              <Input
                id="email"
                type="email"
                placeholder="admin@navigatorusa.org"
                value={loginEmail}
                onChange={(e) => setLoginEmail(e.target.value)}
                className="bg-white/20 border-white/30 text-white placeholder:text-gray-400"
                required
                data-testid="input-login-email"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password" className="text-white">Password</Label>
              <Input
                id="password"
                type="password"
                placeholder="Enter your password"
                value={loginPassword}
                onChange={(e) => setLoginPassword(e.target.value)}
                className="bg-white/20 border-white/30 text-white placeholder:text-gray-400"
                required
                data-testid="input-login-password"
              />
            </div>
            
            {loginError && (
              <div className="text-red-400 text-sm text-center bg-red-500/20 p-2 rounded">
                {loginError}
              </div>
            )}
            
            <Button 
              type="submit"
              className="w-full bg-brand-red hover:bg-brand-red/90"
              disabled={isLoggingIn}
              data-testid="button-login-submit"
            >
              {isLoggingIn ? (
                <span className="flex items-center gap-2">
                  <span className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" />
                  Logging in...
                </span>
              ) : (
                <span className="flex items-center gap-2">
                  <LogIn className="w-4 h-4" />
                  Login to Master Portal
                </span>
              )}
            </Button>
          </form>
        </div>
      </div>
    );
  }

  const viewAffiliateFolder = (affiliate: AffiliateFile) => {
    setSelectedAffiliate(affiliate);
    setShowDocumentViewer(true);
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-brand-navy to-slate-800">
      {/* Header */}
      <div className="bg-black/30 border-b border-white/10 px-6 py-4">
        <div className="flex items-center justify-between max-w-7xl mx-auto">
          <div className="flex items-center gap-3">
            <Shield className="w-8 h-8 text-brand-red" />
            <div>
              <h1 className="text-xl font-bold text-white">Master Portal</h1>
              <p className="text-sm text-gray-400">NavigatorUSA Administration</p>
            </div>
          </div>
          <div className="flex items-center gap-4">
            <span className="text-sm text-gray-400">Logged in as: {authData.user.email}</span>
            <Button 
              variant="outline" 
              size="sm"
              onClick={() => {
                fetch("/api/auth/logout", { method: "POST", credentials: "include" })
                  .then(() => setLocation("/login"));
              }}
              className="border-white/20 text-white hover:bg-white/10"
            >
              Logout
            </Button>
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="max-w-7xl mx-auto p-6">
        <Tabs defaultValue="dashboard" className="w-full">
          <div className="overflow-x-auto pb-2">
            <TabsList className="bg-black/30 border border-white/10 inline-flex min-w-max">
              <TabsTrigger value="dashboard" className="data-[state=active]:bg-brand-red data-[state=active]:text-white text-gray-400">
                <LayoutDashboard className="w-4 h-4 mr-2" />
                Dashboard
              </TabsTrigger>
              <TabsTrigger value="applications" className="data-[state=active]:bg-brand-red data-[state=active]:text-white text-gray-400">
                <ClipboardList className="w-4 h-4 mr-2" />
                Applications
              </TabsTrigger>
              <TabsTrigger value="intakes" className="data-[state=active]:bg-brand-red data-[state=active]:text-white text-gray-400">
                <UserCheck className="w-4 h-4 mr-2" />
                Intakes
              </TabsTrigger>
              <TabsTrigger value="leads" className="data-[state=active]:bg-brand-red data-[state=active]:text-white text-gray-400">
                <HelpCircle className="w-4 h-4 mr-2" />
                Leads & Requests
              </TabsTrigger>
              <TabsTrigger value="sales" className="data-[state=active]:bg-brand-red data-[state=active]:text-white text-gray-400">
                <TrendingUp className="w-4 h-4 mr-2" />
                Sales & Referrals
              </TabsTrigger>
              <TabsTrigger value="files" className="data-[state=active]:bg-brand-red data-[state=active]:text-white text-gray-400">
                <FolderOpen className="w-4 h-4 mr-2" />
                Documents
              </TabsTrigger>
            </TabsList>
          </div>

          {/* Dashboard Tab */}
          <TabsContent value="dashboard" className="mt-6">
            <div className="space-y-6">
              {/* KPI Cards */}
              <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
                <div className="bg-brand-red/20 border border-brand-red/30 rounded-lg p-4">
                  <div className="flex items-center gap-2 mb-2">
                    <ClipboardList className="w-5 h-5 text-brand-red" />
                    <span className="text-xs text-gray-400">Applications</span>
                  </div>
                  <div className="text-2xl font-bold text-white">{affiliateApplications.length}</div>
                  <div className="text-xs text-gray-400">{affiliateApplications.filter((a: any) => a.status === 'pending').length} pending</div>
                </div>
                <div className="bg-blue-500/20 border border-blue-500/30 rounded-lg p-4">
                  <div className="flex items-center gap-2 mb-2">
                    <HelpCircle className="w-5 h-5 text-blue-400" />
                    <span className="text-xs text-gray-400">Help Requests</span>
                  </div>
                  <div className="text-2xl font-bold text-white">{helpRequests.length}</div>
                  <div className="text-xs text-gray-400">{helpRequests.filter((h: any) => h.status === 'pending').length} pending</div>
                </div>
                <div className="bg-green-500/20 border border-green-500/30 rounded-lg p-4">
                  <div className="flex items-center gap-2 mb-2">
                    <DollarSign className="w-5 h-5 text-green-400" />
                    <span className="text-xs text-gray-400">Startup Grants</span>
                  </div>
                  <div className="text-2xl font-bold text-white">{startupGrants.length}</div>
                  <div className="text-xs text-gray-400">{startupGrants.filter((s: any) => s.status === 'pending').length} pending</div>
                </div>
                <div className="bg-purple-500/20 border border-purple-500/30 rounded-lg p-4">
                  <div className="flex items-center gap-2 mb-2">
                    <UserCheck className="w-5 h-5 text-purple-400" />
                    <span className="text-xs text-gray-400">Veteran Intakes</span>
                  </div>
                  <div className="text-2xl font-bold text-white">{veteranIntakes.length}</div>
                  <div className="text-xs text-gray-400">{veteranIntakes.filter((v: any) => v.status === 'pending').length} pending</div>
                </div>
                <div className="bg-yellow-500/20 border border-yellow-500/30 rounded-lg p-4">
                  <div className="flex items-center gap-2 mb-2">
                    <Briefcase className="w-5 h-5 text-yellow-400" />
                    <span className="text-xs text-gray-400">Business Leads</span>
                  </div>
                  <div className="text-2xl font-bold text-white">{businessLeads.length}</div>
                  <div className="text-xs text-gray-400">{businessLeads.filter((b: any) => b.status === 'new').length} new</div>
                </div>
                <div className="bg-cyan-500/20 border border-cyan-500/30 rounded-lg p-4">
                  <div className="flex items-center gap-2 mb-2">
                    <TrendingUp className="w-5 h-5 text-cyan-400" />
                    <span className="text-xs text-gray-400">Total Sales</span>
                  </div>
                  <div className="text-2xl font-bold text-white">{salesData.length}</div>
                  <div className="text-xs text-gray-400">${salesData.reduce((sum: number, s: any) => sum + (s.amount || 0), 0).toLocaleString()}</div>
                </div>
              </div>

              {/* Alerts Section */}
              <div className="bg-black/20 rounded-lg border border-white/10 p-4">
                <h3 className="text-lg font-bold text-white mb-4 flex items-center gap-2">
                  <AlertCircle className="w-5 h-5 text-yellow-400" />
                  Pending Actions
                </h3>
                <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {affiliateApplications.filter((a: any) => a.status === 'pending').length > 0 && (
                    <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-3 flex items-center gap-3">
                      <Clock className="w-5 h-5 text-yellow-400" />
                      <div>
                        <div className="text-white font-medium">{affiliateApplications.filter((a: any) => a.status === 'pending').length} Affiliate Apps</div>
                        <div className="text-xs text-gray-400">Awaiting review</div>
                      </div>
                    </div>
                  )}
                  {helpRequests.filter((h: any) => h.status === 'pending').length > 0 && (
                    <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-3 flex items-center gap-3">
                      <Clock className="w-5 h-5 text-yellow-400" />
                      <div>
                        <div className="text-white font-medium">{helpRequests.filter((h: any) => h.status === 'pending').length} Help Requests</div>
                        <div className="text-xs text-gray-400">Need attention</div>
                      </div>
                    </div>
                  )}
                  {privateDoctorRequests.filter((p: any) => p.status === 'pending').length > 0 && (
                    <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-3 flex items-center gap-3">
                      <Stethoscope className="w-5 h-5 text-red-400" />
                      <div>
                        <div className="text-white font-medium">{privateDoctorRequests.filter((p: any) => p.status === 'pending').length} Doctor Requests</div>
                        <div className="text-xs text-gray-400">Urgent - medical</div>
                      </div>
                    </div>
                  )}
                </div>
              </div>

              {/* Quick Stats Grid */}
              <div className="grid md:grid-cols-3 gap-4">
                <div className="bg-black/20 rounded-lg border border-white/10 p-4">
                  <h4 className="text-sm font-bold text-gray-400 mb-3">APPLICATIONS</h4>
                  <div className="space-y-2">
                    <div className="flex justify-between"><span className="text-gray-300">Affiliate Apps</span><span className="text-white font-bold">{affiliateApplications.length}</span></div>
                    <div className="flex justify-between"><span className="text-gray-300">Startup Grants</span><span className="text-white font-bold">{startupGrants.length}</span></div>
                    <div className="flex justify-between"><span className="text-gray-300">Website Grants</span><span className="text-white font-bold">{websiteApplications.length}</span></div>
                  </div>
                </div>
                <div className="bg-black/20 rounded-lg border border-white/10 p-4">
                  <h4 className="text-sm font-bold text-gray-400 mb-3">INTAKES</h4>
                  <div className="space-y-2">
                    <div className="flex justify-between"><span className="text-gray-300">Veteran</span><span className="text-white font-bold">{veteranIntakes.length}</span></div>
                    <div className="flex justify-between"><span className="text-gray-300">Business</span><span className="text-white font-bold">{businessIntakes.length}</span></div>
                    <div className="flex justify-between"><span className="text-gray-300">Insurance</span><span className="text-white font-bold">{insuranceIntakes.length}</span></div>
                    <div className="flex justify-between"><span className="text-gray-300">Medical Sales</span><span className="text-white font-bold">{medicalSalesIntakes.length}</span></div>
                  </div>
                </div>
                <div className="bg-black/20 rounded-lg border border-white/10 p-4">
                  <h4 className="text-sm font-bold text-gray-400 mb-3">LEADS & REQUESTS</h4>
                  <div className="space-y-2">
                    <div className="flex justify-between"><span className="text-gray-300">Help Requests</span><span className="text-white font-bold">{helpRequests.length}</span></div>
                    <div className="flex justify-between"><span className="text-gray-300">Private Doctor</span><span className="text-white font-bold">{privateDoctorRequests.length}</span></div>
                    <div className="flex justify-between"><span className="text-gray-300">Furniture</span><span className="text-white font-bold">{furnitureAssistance.length}</span></div>
                    <div className="flex justify-between"><span className="text-gray-300">General Contact</span><span className="text-white font-bold">{generalContact.length}</span></div>
                  </div>
                </div>
              </div>
            </div>
          </TabsContent>

          {/* Applications Tab */}
          <TabsContent value="applications" className="mt-6">
            <Tabs defaultValue="affiliate-apps" className="w-full">
              <TabsList className="bg-black/20 border border-white/10 mb-4">
                <TabsTrigger value="affiliate-apps" className="data-[state=active]:bg-brand-navy text-gray-400">Affiliate Apps ({affiliateApplications.length})</TabsTrigger>
                <TabsTrigger value="startup-grants" className="data-[state=active]:bg-brand-navy text-gray-400">Startup Grants ({startupGrants.length})</TabsTrigger>
                <TabsTrigger value="website-apps" className="data-[state=active]:bg-brand-navy text-gray-400">Website Grants ({websiteApplications.length})</TabsTrigger>
              </TabsList>
              <TabsContent value="affiliate-apps">
                <div className="bg-black/20 rounded-lg border border-white/10 overflow-hidden" data-testid="datatable-affiliate-applications">
                  <div className="p-4 border-b border-white/10 flex items-center justify-between">
                    <h2 className="text-lg font-bold text-white flex items-center gap-2">
                      <ClipboardList className="w-5 h-5 text-brand-red" />
                      Affiliate Applications
                    </h2>
                    <div className="flex items-center gap-2">
                      <Input
                        type="password"
                        placeholder="Security key for PDFs"
                        value={pdfSecurityKey}
                        onChange={(e) => setPdfSecurityKey(e.target.value)}
                        className="w-48 bg-black/30 border-white/20 text-white text-sm"
                        data-testid="input-apps-pdf-security-key"
                      />
                    </div>
                  </div>
                  {affiliateApplications.length === 0 ? (
                    <div className="p-8 text-center text-gray-400">No affiliate applications found.</div>
                  ) : (
                    <div className="overflow-x-auto">
                      <table className="w-full">
                        <thead className="bg-black/30">
                          <tr>
                            <th className="px-4 py-3 text-left text-xs font-bold text-gray-400 uppercase tracking-wider">Name</th>
                            <th className="px-4 py-3 text-left text-xs font-bold text-gray-400 uppercase tracking-wider">Email</th>
                            <th className="px-4 py-3 text-left text-xs font-bold text-gray-400 uppercase tracking-wider">Phone</th>
                            <th className="px-4 py-3 text-left text-xs font-bold text-gray-400 uppercase tracking-wider">Status</th>
                            <th className="px-4 py-3 text-left text-xs font-bold text-gray-400 uppercase tracking-wider">Date</th>
                            <th className="px-4 py-3 text-left text-xs font-bold text-gray-400 uppercase tracking-wider">NDA</th>
                          </tr>
                        </thead>
                        <tbody className="divide-y divide-white/10">
                          {affiliateApplications.slice(0, 50).map((app: any) => {
                            const matchingNda = affiliateFiles.find((af: AffiliateFile) => af.email?.toLowerCase() === app.email?.toLowerCase());
                            return (
                              <tr key={app.id} className="hover:bg-white/5">
                                <td className="px-4 py-3 text-sm text-gray-300">{app.name}</td>
                                <td className="px-4 py-3 text-sm text-gray-300">{app.email}</td>
                                <td className="px-4 py-3 text-sm text-gray-300">{app.phone || '-'}</td>
                                <td className="px-4 py-3 text-sm">
                                  <span className={`px-2 py-1 rounded-full text-xs font-medium ${
                                    app.status === 'pending' || app.status === 'new' ? 'bg-yellow-500/20 text-yellow-400' :
                                    app.status === 'approved' || app.status === 'completed' ? 'bg-green-500/20 text-green-400' :
                                    app.status === 'rejected' ? 'bg-red-500/20 text-red-400' :
                                    'bg-gray-500/20 text-gray-400'
                                  }`}>
                                    {app.status || 'new'}
                                  </span>
                                </td>
                                <td className="px-4 py-3 text-sm text-gray-300">{new Date(app.createdAt).toLocaleDateString()}</td>
                                <td className="px-4 py-3 text-sm">
                                  {matchingNda?.nda ? (
                                    <Button
                                      size="sm"
                                      onClick={() => downloadNdaPdf(matchingNda.nda!.id, matchingNda.nda!.fullName)}
                                      disabled={isDownloadingPdf || !pdfSecurityKey}
                                      className="bg-brand-red hover:bg-red-700 text-white text-xs px-2 py-1 h-7"
                                      data-testid={`btn-download-nda-${app.id}`}
                                    >
                                      <FileDown className="w-3 h-3 mr-1" />
                                      PDF
                                    </Button>
                                  ) : (
                                    <span className="text-gray-500 text-xs">No NDA</span>
                                  )}
                                </td>
                              </tr>
                            );
                          })}
                        </tbody>
                      </table>
                      {affiliateApplications.length > 50 && (
                        <div className="p-3 text-center text-sm text-gray-400 border-t border-white/10">
                          Showing 50 of {affiliateApplications.length} records
                        </div>
                      )}
                    </div>
                  )}
                  {pdfDownloadError && (
                    <div className="p-3 text-center text-red-400 text-sm border-t border-white/10">{pdfDownloadError}</div>
                  )}
                </div>
              </TabsContent>
              <TabsContent value="startup-grants">
                <DataTable title="Startup Grant Applications" icon={<DollarSign className="w-5 h-5 text-green-400" />} data={startupGrants} columns={["businessName", "firstName", "lastName", "email", "status", "createdAt"]} />
              </TabsContent>
              <TabsContent value="website-apps">
                <DataTable title="Website Grant Applications" icon={<Globe className="w-5 h-5 text-blue-400" />} data={websiteApplications} columns={["businessName", "firstName", "lastName", "email", "status", "createdAt"]} />
              </TabsContent>
            </Tabs>
          </TabsContent>

          {/* Intakes Tab */}
          <TabsContent value="intakes" className="mt-6">
            <Tabs defaultValue="veteran" className="w-full">
              <TabsList className="bg-black/20 border border-white/10 mb-4 flex-wrap">
                <TabsTrigger value="veteran" className="data-[state=active]:bg-brand-navy text-gray-400">Veteran ({veteranIntakes.length})</TabsTrigger>
                <TabsTrigger value="business" className="data-[state=active]:bg-brand-navy text-gray-400">Business ({businessIntakes.length})</TabsTrigger>
                <TabsTrigger value="insurance" className="data-[state=active]:bg-brand-navy text-gray-400">Insurance ({insuranceIntakes.length})</TabsTrigger>
                <TabsTrigger value="medical-sales" className="data-[state=active]:bg-brand-navy text-gray-400">Medical Sales ({medicalSalesIntakes.length})</TabsTrigger>
                <TabsTrigger value="business-dev" className="data-[state=active]:bg-brand-navy text-gray-400">Business Dev ({businessDevIntakes.length})</TabsTrigger>
                <TabsTrigger value="healthcare-tab" className="data-[state=active]:bg-brand-navy text-gray-400">Healthcare ({healthcareIntakes.length})</TabsTrigger>
                <TabsTrigger value="vet-prof" className="data-[state=active]:bg-brand-navy text-gray-400">Vet Professionals ({vetProfessionalIntakes.length})</TabsTrigger>
              </TabsList>
              <TabsContent value="veteran">
                <DataTable title="Veteran Intakes" icon={<Shield className="w-5 h-5 text-brand-red" />} data={veteranIntakes} columns={["firstName", "lastName", "email", "phone", "intakeType", "status", "createdAt"]} />
              </TabsContent>
              <TabsContent value="business">
                <DataTable title="Business Intakes" icon={<Briefcase className="w-5 h-5 text-yellow-400" />} data={businessIntakes} columns={["businessName", "contactName", "email", "phone", "serviceType", "status", "createdAt"]} />
              </TabsContent>
              <TabsContent value="insurance">
                <DataTable title="Insurance Intakes" icon={<Shield className="w-5 h-5 text-blue-400" />} data={insuranceIntakes} columns={["businessName", "contactName", "email", "phone", "status", "createdAt"]} />
              </TabsContent>
              <TabsContent value="medical-sales">
                <DataTable title="Medical Sales Intakes" icon={<Stethoscope className="w-5 h-5 text-green-400" />} data={medicalSalesIntakes} columns={["firstName", "lastName", "email", "phone", "role", "status", "createdAt"]} />
              </TabsContent>
              <TabsContent value="business-dev">
                <DataTable title="Business Development Intakes" icon={<Target className="w-5 h-5 text-purple-400" />} data={businessDevIntakes} columns={["businessName", "contactName", "email", "phone", "serviceType", "status", "createdAt"]} />
              </TabsContent>
              <TabsContent value="healthcare-tab">
                <DataTable title="Healthcare Intakes" icon={<Heart className="w-5 h-5 text-red-400" />} data={healthcareIntakes} columns={["firstName", "lastName", "email", "phone", "treatmentType", "status", "createdAt"]} />
              </TabsContent>
              <TabsContent value="vet-prof">
                <DataTable title="Vet Professional Intakes" icon={<UserCheck className="w-5 h-5 text-cyan-400" />} data={vetProfessionalIntakes} columns={["firstName", "lastName", "email", "phone", "profession", "status", "createdAt"]} />
              </TabsContent>
            </Tabs>
          </TabsContent>

          {/* Leads & Requests Tab */}
          <TabsContent value="leads" className="mt-6">
            <Tabs defaultValue="help-requests" className="w-full">
              <TabsList className="bg-black/20 border border-white/10 mb-4 flex-wrap">
                <TabsTrigger value="help-requests" className="data-[state=active]:bg-brand-navy text-gray-400">Help Requests ({helpRequests.length})</TabsTrigger>
                <TabsTrigger value="private-doctor" className="data-[state=active]:bg-brand-navy text-gray-400">Private Doctor ({privateDoctorRequests.length})</TabsTrigger>
                <TabsTrigger value="furniture" className="data-[state=active]:bg-brand-navy text-gray-400">Furniture ({furnitureAssistance.length})</TabsTrigger>
                <TabsTrigger value="contact" className="data-[state=active]:bg-brand-navy text-gray-400">General Contact ({generalContact.length})</TabsTrigger>
                <TabsTrigger value="business-leads-tab" className="data-[state=active]:bg-brand-navy text-gray-400">Business Leads ({businessLeads.length})</TabsTrigger>
              </TabsList>
              <TabsContent value="help-requests">
                <DataTable title="VA Help Requests" icon={<HelpCircle className="w-5 h-5 text-blue-400" />} data={helpRequests} columns={["name", "email", "phone", "helpType", "otherHelpType", "description", "referralCode", "status", "createdAt"]} />
              </TabsContent>
              <TabsContent value="private-doctor">
                <DataTable title="Private Doctor Requests" icon={<Stethoscope className="w-5 h-5 text-red-400" />} data={privateDoctorRequests} columns={["firstName", "lastName", "email", "phone", "zip", "branch", "careType", "situation", "status", "createdAt"]} />
              </TabsContent>
              <TabsContent value="furniture">
                <DataTable title="Furniture Assistance" icon={<Sofa className="w-5 h-5 text-yellow-400" />} data={furnitureAssistance} columns={["firstName", "lastName", "email", "phone", "branch", "serviceStatus", "homeStatus", "expectedCloseDate", "homeLocation", "additionalInfo", "status", "createdAt"]} />
              </TabsContent>
              <TabsContent value="contact">
                <DataTable title="General Contact" icon={<Mail className="w-5 h-5 text-gray-400" />} data={generalContact} columns={["name", "email", "phone", "subject", "message", "status", "createdAt"]} />
              </TabsContent>
              <TabsContent value="business-leads-tab">
                <DataTable title="Business Leads" icon={<Building className="w-5 h-5 text-green-400" />} data={businessLeads} columns={["businessName", "contactName", "position", "email", "phone", "leadType", "comment", "referralCode", "status", "createdAt"]} />
              </TabsContent>
            </Tabs>
          </TabsContent>

          {/* Sales & Referrals Tab */}
          <TabsContent value="sales" className="mt-6">
            <Tabs defaultValue="partner-refs" className="w-full">
              <TabsList className="bg-black/20 border border-white/10 mb-4">
                <TabsTrigger value="partner-refs" className="data-[state=active]:bg-brand-navy text-gray-400">Partner Referrals ({finopsReferrals.length})</TabsTrigger>
                <TabsTrigger value="disability-refs" className="data-[state=active]:bg-brand-navy text-gray-400">Disability Referrals ({disabilityReferrals.length})</TabsTrigger>
                <TabsTrigger value="sales-data" className="data-[state=active]:bg-brand-navy text-gray-400">Sales ({salesData.length})</TabsTrigger>
              </TabsList>
              <TabsContent value="partner-refs">
                <div className="bg-black/20 rounded-lg border border-white/10 overflow-hidden">
                  <div className="p-4 border-b border-white/10">
                    <h2 className="text-lg font-bold text-white flex items-center gap-2">
                      <Link2 className="w-5 h-5 text-brand-red" />
                      Partner Referral Tracking
                    </h2>
                  </div>
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4 p-4 border-b border-white/10">
                    <div className="bg-brand-gold/20 rounded-lg p-4 text-center">
                      <Store className="w-6 h-6 text-brand-gold mx-auto mb-2" />
                      <div className="text-xl font-bold text-white">{finopsReferrals.filter((r: any) => r.partnerType === 'my_locker').length}</div>
                      <div className="text-xs text-gray-400">MY LOCKER</div>
                    </div>
                    <div className="bg-brand-red/20 rounded-lg p-4 text-center">
                      <CreditCard className="w-6 h-6 text-brand-red mx-auto mb-2" />
                      <div className="text-xl font-bold text-white">{finopsReferrals.filter((r: any) => r.partnerType === 'merchant_services').length}</div>
                      <div className="text-xs text-gray-400">Merchant</div>
                    </div>
                    <div className="bg-brand-blue/20 rounded-lg p-4 text-center">
                      <Gift className="w-6 h-6 text-brand-blue mx-auto mb-2" />
                      <div className="text-xl font-bold text-white">{finopsReferrals.filter((r: any) => r.partnerType === 'vgift_cards').length}</div>
                      <div className="text-xs text-gray-400">vGift Cards</div>
                    </div>
                    <div className="bg-white/10 rounded-lg p-4 text-center">
                      <Link2 className="w-6 h-6 text-white mx-auto mb-2" />
                      <div className="text-xl font-bold text-white">{finopsReferrals.length}</div>
                      <div className="text-xs text-gray-400">Total</div>
                    </div>
                  </div>
                  <DataTable title="" icon={null} data={finopsReferrals} columns={["referralCode", "partnerType", "status", "createdAt"]} hideHeader />
                </div>
              </TabsContent>
              <TabsContent value="disability-refs">
                <DataTable title="Disability Referrals" icon={<Shield className="w-5 h-5 text-brand-red" />} data={disabilityReferrals} columns={["firstName", "lastName", "email", "phone", "ratingType", "status", "createdAt"]} />
              </TabsContent>
              <TabsContent value="sales-data">
                <DataTable title="Sales Transactions" icon={<TrendingUp className="w-5 h-5 text-green-400" />} data={salesData} columns={["affiliateId", "opportunityId", "amount", "status", "createdAt"]} />
              </TabsContent>
            </Tabs>
          </TabsContent>

          {/* Documents Tab */}
          <TabsContent value="files" className="mt-6">
            <Tabs defaultValue="signed-ndas" className="w-full">
              <TabsList className="bg-black/20 border border-white/10 mb-4">
                <TabsTrigger value="signed-ndas" className="data-[state=active]:bg-brand-navy text-gray-400">Signed NDAs ({affiliateFiles.filter((af: AffiliateFile) => af.nda).length})</TabsTrigger>
                <TabsTrigger value="schedule-a-sub" className="data-[state=active]:bg-brand-navy text-gray-400">Schedule A ({scheduleASignatures.length})</TabsTrigger>
              </TabsList>
              <TabsContent value="signed-ndas">
                <div className="bg-black/20 rounded-lg border border-white/10 overflow-hidden">
                  <div className="p-4 border-b border-white/10 bg-black/20 flex items-center justify-between">
                    <div>
                      <h2 className="text-lg font-bold text-white flex items-center gap-2">
                        <FileSignature className="w-5 h-5 text-brand-red" />
                        Signed NDAs
                      </h2>
                      <p className="text-sm text-gray-400 mt-1">
                        All affiliate NDA agreements with PDF download
                      </p>
                    </div>
                    <div className="flex items-center gap-3">
                      <Input
                        type="password"
                        placeholder="Security key for PDFs"
                        value={pdfSecurityKey}
                        onChange={(e) => setPdfSecurityKey(e.target.value)}
                        className="w-48 bg-black/30 border-white/20 text-white text-sm"
                        data-testid="input-nda-security-key"
                      />
                      <Button
                        onClick={() => queryClient.invalidateQueries({ queryKey: ["master-affiliate-files"] })}
                        variant="outline"
                        size="sm"
                        className="border-white/20 text-white hover:bg-white/10"
                        data-testid="button-refresh-ndas"
                      >
                        <RefreshCw className={`w-4 h-4 ${filesLoading ? 'animate-spin' : ''}`} />
                      </Button>
                    </div>
                  </div>

                  {pdfDownloadError && (
                    <div className="p-3 bg-red-500/20 border-b border-red-500/30 text-red-400 text-sm text-center">
                      {pdfDownloadError}
                    </div>
                  )}

                  {filesLoading ? (
                    <div className="p-8 text-center">
                      <div className="animate-spin w-8 h-8 border-4 border-brand-red border-t-transparent rounded-full mx-auto"></div>
                      <p className="text-gray-400 mt-4">Loading signed NDAs...</p>
                    </div>
                  ) : filesError ? (
                    <div className="p-8 text-center text-red-400">
                      <p className="font-bold">Error loading signed NDAs</p>
                      <p className="text-sm mt-2">{(filesError as Error).message}</p>
                    </div>
                  ) : affiliateFiles.filter((af: AffiliateFile) => af.nda).length === 0 ? (
                    <div className="p-8 text-center text-gray-400">
                      No signed NDAs found.
                    </div>
                  ) : (
                    <div className="overflow-x-auto">
                      <table className="w-full">
                        <thead className="bg-black/30">
                          <tr>
                            <th className="px-4 py-3 text-left text-xs font-bold text-gray-400 uppercase">Name</th>
                            <th className="px-4 py-3 text-left text-xs font-bold text-gray-400 uppercase">Email</th>
                            <th className="px-4 py-3 text-left text-xs font-bold text-gray-400 uppercase">Address</th>
                            <th className="px-4 py-3 text-left text-xs font-bold text-gray-400 uppercase">Signed</th>
                            <th className="px-4 py-3 text-left text-xs font-bold text-gray-400 uppercase">Download</th>
                          </tr>
                        </thead>
                        <tbody className="divide-y divide-white/10">
                          {affiliateFiles.filter((af: AffiliateFile) => af.nda).map((affiliate: AffiliateFile) => (
                            <tr key={affiliate.id} className="hover:bg-white/5">
                              <td className="px-4 py-3 text-sm text-white font-medium">{affiliate.nda?.fullName || affiliate.name}</td>
                              <td className="px-4 py-3 text-sm text-gray-300">{affiliate.email}</td>
                              <td className="px-4 py-3 text-sm text-gray-400 max-w-xs truncate">{affiliate.nda?.address || '-'}</td>
                              <td className="px-4 py-3 text-sm text-gray-400">
                                {affiliate.nda?.signedAt ? new Date(affiliate.nda.signedAt).toLocaleDateString() : '-'}
                              </td>
                              <td className="px-4 py-3">
                                <Button
                                  size="sm"
                                  onClick={() => downloadNdaPdf(affiliate.nda!.id, affiliate.nda!.fullName)}
                                  disabled={isDownloadingPdf || !pdfSecurityKey}
                                  className="bg-brand-red hover:bg-red-700 text-white"
                                  data-testid={`btn-download-nda-${affiliate.id}`}
                                >
                                  <FileDown className="w-4 h-4 mr-1" />
                                  PDF
                                </Button>
                              </td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                  )}
                </div>
              </TabsContent>
              <TabsContent value="schedule-a-sub">
                <div className="bg-black/20 rounded-lg border border-white/10 overflow-hidden">
                  <div className="p-4 border-b border-white/10 bg-black/20">
                    <h2 className="text-lg font-bold text-white flex items-center gap-2">
                      <Shield className="w-5 h-5 text-brand-red" />
                      Schedule A Signatures
                    </h2>
                    <p className="text-sm text-gray-400 mt-1">
                      Track affiliate acknowledgments of the commission structure
                    </p>
                  </div>

              {/* Stats */}
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4 p-4 border-b border-white/10" data-testid="schedule-a-stats">
                <div className="bg-black/30 rounded-lg p-4 text-center">
                  <div className="text-3xl font-bold text-green-400" data-testid="stat-schedule-a-total">{scheduleASignatures.length}</div>
                  <div className="text-sm text-gray-400">Total Signatures</div>
                </div>
                <div className="bg-black/30 rounded-lg p-4 text-center">
                  <div className="text-3xl font-bold text-blue-400" data-testid="stat-schedule-a-30days">
                    {scheduleASignatures.filter((s: any) => {
                      const signedDate = new Date(s.signedAt);
                      const thirtyDaysAgo = new Date();
                      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                      return signedDate >= thirtyDaysAgo;
                    }).length}
                  </div>
                  <div className="text-sm text-gray-400">Last 30 Days</div>
                </div>
                <div className="bg-black/30 rounded-lg p-4 text-center">
                  <div className="text-3xl font-bold text-purple-400" data-testid="stat-schedule-a-7days">
                    {scheduleASignatures.filter((s: any) => {
                      const signedDate = new Date(s.signedAt);
                      const sevenDaysAgo = new Date();
                      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
                      return signedDate >= sevenDaysAgo;
                    }).length}
                  </div>
                  <div className="text-sm text-gray-400">Last 7 Days</div>
                </div>
                <div className="bg-black/30 rounded-lg p-4 text-center">
                  <div className="text-3xl font-bold text-yellow-400" data-testid="stat-schedule-a-version">1.0</div>
                  <div className="text-sm text-gray-400">Current Version</div>
                </div>
              </div>

              {scheduleALoading ? (
                <div className="p-8 text-center">
                  <div className="animate-spin w-8 h-8 border-4 border-brand-red border-t-transparent rounded-full mx-auto"></div>
                  <p className="text-gray-400 mt-4">Loading signatures...</p>
                </div>
              ) : scheduleASignatures.length === 0 ? (
                <div className="p-8 text-center text-gray-400">
                  No Schedule A signatures yet.
                </div>
              ) : (
                <div className="overflow-x-auto">
                  <table className="w-full text-sm">
                    <thead className="bg-black/30 text-gray-400">
                      <tr>
                        <th className="text-left p-3">Name</th>
                        <th className="text-left p-3">Email</th>
                        <th className="text-left p-3">Signed At</th>
                        <th className="text-left p-3">IP Address</th>
                        <th className="text-left p-3">Version</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-white/10" data-testid="schedule-a-table-body">
                      {scheduleASignatures.map((sig: any) => (
                        <tr key={sig.id} className="hover:bg-white/5" data-testid={`row-schedule-a-${sig.id}`}>
                          <td className="p-3 text-white font-medium" data-testid={`text-schedule-a-name-${sig.id}`}>{sig.affiliateName}</td>
                          <td className="p-3 text-gray-400" data-testid={`text-schedule-a-email-${sig.id}`}>{sig.affiliateEmail}</td>
                          <td className="p-3 text-gray-400">
                            {new Date(sig.signedAt).toLocaleDateString('en-US', {
                              year: 'numeric',
                              month: 'short',
                              day: 'numeric',
                              hour: '2-digit',
                              minute: '2-digit'
                            })}
                          </td>
                          <td className="p-3 text-gray-500 font-mono text-xs">{sig.ipAddress || 'N/A'}</td>
                          <td className="p-3">
                            <span className="px-2 py-1 rounded text-xs bg-green-500/20 text-green-400">
                              v{sig.version}
                            </span>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                )}
                </div>
              </TabsContent>
            </Tabs>
          </TabsContent>
        </Tabs>
      </div>

      {/* Document Viewer Dialog */}
      <Dialog open={showDocumentViewer} onOpenChange={setShowDocumentViewer}>
        <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto bg-slate-900 border-white/20 text-white">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2 text-xl">
              <FolderOpen className="w-6 h-6 text-brand-red" />
              {selectedAffiliate?.name}'s Document Folder
            </DialogTitle>
          </DialogHeader>

          {selectedAffiliate && (
            <div className="space-y-6 mt-4">
              {/* Face Photo Section */}
              {selectedAffiliate.nda?.facePhoto && (
                <div className="bg-black/30 rounded-lg p-4 border border-white/10">
                  <h3 className="font-bold text-white flex items-center gap-2 mb-3">
                    <Camera className="w-5 h-5 text-brand-red" />
                    Face Photo
                  </h3>
                  <img 
                    src={selectedAffiliate.nda.facePhoto} 
                    alt="Face Photo" 
                    className="max-w-xs rounded-lg border border-white/20"
                    data-testid="img-face-photo"
                  />
                </div>
              )}

              {/* ID Photo Section */}
              {selectedAffiliate.nda?.idPhoto && (
                <div className="bg-black/30 rounded-lg p-4 border border-white/10">
                  <h3 className="font-bold text-white flex items-center gap-2 mb-3">
                    <IdCard className="w-5 h-5 text-brand-red" />
                    Government ID
                  </h3>
                  <img 
                    src={selectedAffiliate.nda.idPhoto} 
                    alt="ID Photo" 
                    className="max-w-md rounded-lg border border-white/20"
                    data-testid="img-id-photo"
                  />
                </div>
              )}

              {/* NDA Section */}
              {selectedAffiliate.nda && (
                <div className="bg-black/30 rounded-lg p-4 border border-white/10">
                  <h3 className="font-bold text-white flex items-center gap-2 mb-3">
                    <FileSignature className="w-5 h-5 text-brand-red" />
                    NDA / Confidentiality Agreement
                  </h3>
                  <div className="grid grid-cols-2 gap-4 text-sm">
                    <div>
                      <span className="text-gray-400">Full Name:</span>
                      <p className="text-white">{selectedAffiliate.nda.fullName}</p>
                    </div>
                    <div>
                      <span className="text-gray-400">Address:</span>
                      <p className="text-white">{selectedAffiliate.nda.address}</p>
                    </div>
                    <div>
                      <span className="text-gray-400">Signed On:</span>
                      <p className="text-white">{new Date(selectedAffiliate.nda.signedAt).toLocaleString()}</p>
                    </div>
                  </div>
                  {selectedAffiliate.nda.signatureData && (
                    <div className="mt-4">
                      <span className="text-gray-400 text-sm">Signature:</span>
                      <img 
                        src={selectedAffiliate.nda.signatureData} 
                        alt="NDA Signature" 
                        className="bg-white rounded mt-2 max-w-xs"
                      />
                    </div>
                  )}
                  
                  {/* PDF Download Section */}
                  <div className="mt-4 pt-4 border-t border-white/10">
                    <div className="flex items-center gap-3">
                      <Input
                        type="password"
                        placeholder="Enter security key"
                        value={pdfSecurityKey}
                        onChange={(e) => setPdfSecurityKey(e.target.value)}
                        className="flex-1 max-w-xs bg-black/30 border-white/20 text-white"
                        data-testid="input-pdf-security-key"
                      />
                      <Button
                        onClick={() => downloadNdaPdf(selectedAffiliate.nda!.id, selectedAffiliate.nda!.fullName)}
                        disabled={isDownloadingPdf || !pdfSecurityKey}
                        className="bg-brand-gold hover:bg-brand-gold/90 text-black"
                        data-testid="button-download-nda-pdf"
                      >
                        <Download className="w-4 h-4 mr-2" />
                        {isDownloadingPdf ? "Generating..." : "Download PDF"}
                      </Button>
                    </div>
                    {pdfDownloadError && (
                      <p className="text-red-400 text-sm mt-2" data-testid="text-pdf-error">{pdfDownloadError}</p>
                    )}
                  </div>
                </div>
              )}

              {/* Contracts Section */}
              {selectedAffiliate.contracts && selectedAffiliate.contracts.length > 0 && (
                <div className="bg-black/30 rounded-lg p-4 border border-white/10">
                  <h3 className="font-bold text-white flex items-center gap-2 mb-3">
                    <ClipboardCheck className="w-5 h-5 text-brand-red" />
                    Signed Contracts ({selectedAffiliate.contracts.length})
                  </h3>
                  <div className="space-y-3">
                    {selectedAffiliate.contracts.map((contract) => (
                      <div key={contract.id} className="bg-black/20 rounded p-3 border border-white/5">
                        <div className="flex justify-between items-center">
                          <span className="font-medium text-white">{contract.contractName}</span>
                          <span className="text-sm text-gray-400">
                            Signed: {new Date(contract.signedAt).toLocaleDateString()}
                          </span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* W9 Section */}
              {selectedAffiliate.w9 && (
                <div className="bg-black/30 rounded-lg p-4 border border-white/10">
                  <h3 className="font-bold text-white flex items-center gap-2 mb-3">
                    <Receipt className="w-5 h-5 text-brand-red" />
                    W-9 Tax Form
                  </h3>
                  <div className="grid grid-cols-2 gap-4 text-sm">
                    <div>
                      <span className="text-gray-400">Name:</span>
                      <p className="text-white">{selectedAffiliate.w9.name}</p>
                    </div>
                    <div>
                      <span className="text-gray-400">Tax Classification:</span>
                      <p className="text-white capitalize">{selectedAffiliate.w9.taxClassification.replace(/_/g, ' ')}</p>
                    </div>
                    <div className="col-span-2">
                      <span className="text-gray-400">Address:</span>
                      <p className="text-white">
                        {selectedAffiliate.w9.address}, {selectedAffiliate.w9.city}, {selectedAffiliate.w9.state} {selectedAffiliate.w9.zip}
                      </p>
                    </div>
                    <div>
                      <span className="text-gray-400">Certified On:</span>
                      <p className="text-white">{new Date(selectedAffiliate.w9.certificationDate).toLocaleString()}</p>
                    </div>
                  </div>
                </div>
              )}

              {/* No documents message */}
              {!selectedAffiliate.nda && (!selectedAffiliate.contracts || selectedAffiliate.contracts.length === 0) && !selectedAffiliate.w9 && (
                <div className="text-center text-gray-400 py-8">
                  No documents found for this affiliate.
                </div>
              )}
            </div>
          )}
        </DialogContent>
      </Dialog>
    </div>
  );
}


========== SERVER ROUTES ==========


import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import session from "express-session";
import pgSession from "connect-pg-simple";
import pg from "pg";
import { storage } from "./storage";
import { authenticateUser, createAdminUser, createAffiliateUser, hashPassword } from "./auth";
import { Resend } from "resend";
import twilio from "twilio";
import Stripe from "stripe";
import { 
  insertAffiliateApplicationSchema, 
  insertHelpRequestSchema, 
  insertStartupGrantSchema, 
  insertFurnitureAssistanceSchema,
  insertInvestorSubmissionSchema,
  insertPrivateDoctorRequestSchema,
  insertWebsiteApplicationSchema,
  insertGeneralContactSchema,
  insertVltIntakeSchema,
  insertOpportunitySchema,
  insertSaleSchema,
  insertVeteranIntakeSchema,
  insertBusinessIntakeSchema,
  insertContractTemplateSchema,
  insertSignedAgreementSchema,
  insertBusinessLeadSchema,
  insertDisabilityReferralSchema,
  insertJobPlacementIntakeSchema,
  insertScheduleASignatureSchema,
  insertInsuranceIntakeSchema,
  insertMedicalSalesIntakeSchema,
  insertBusinessDevIntakeSchema
} from "@shared/schema";
import { z } from "zod";

declare module "express-session" {
  interface SessionData {
    userId: number;
    userRole: string;
    vltAffiliateId: number;
  }
}

// Middleware to check if user is authenticated
function requireAuth(req: Request, res: Response, next: NextFunction) {
  if (!req.session.userId) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  next();
}

// Middleware to check if user is admin or master
function requireAdmin(req: Request, res: Response, next: NextFunction) {
  if (!req.session.userId || (req.session.userRole !== "admin" && req.session.userRole !== "master")) {
    return res.status(403).json({ message: "Forbidden - Admin access required" });
  }
  next();
}

// Middleware to check if user is affiliate
function requireAffiliate(req: Request, res: Response, next: NextFunction) {
  if (!req.session.userId || req.session.userRole !== "affiliate") {
    return res.status(403).json({ message: "Forbidden" });
  }
  next();
}

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  // Trust proxy for Replit's load balancer (needed in both dev and production)
  app.set('trust proxy', 1);

  // PostgreSQL session store for persistent sessions
  const PgStore = pgSession(session);
  
  if (!process.env.DATABASE_URL) {
    throw new Error("DATABASE_URL must be set for session storage");
  }
  
  // Create session pool with error handling
  const sessionPool = new pg.Pool({
    connectionString: process.env.DATABASE_URL,
    max: 10,
    ssl: process.env.NODE_ENV === "production" ? { rejectUnauthorized: false } : undefined,
  });
  
  // Handle pool errors to prevent crashes
  sessionPool.on('error', (err) => {
    console.error('Session pool error:', err);
  });

  // Verify session pool connectivity on startup
  try {
    const client = await sessionPool.connect();
    await client.query('SELECT 1');
    client.release();
    console.log('[session] PostgreSQL session store connected successfully');
  } catch (err) {
    console.error('[session] Failed to connect to session store:', err);
    throw new Error('Session store connection failed - cannot start server');
  }

  const sessionStore = new PgStore({
    pool: sessionPool,
    tableName: "session",
    createTableIfMissing: true,
    pruneSessionInterval: 60 * 15, // Prune expired sessions every 15 minutes
  });

  // Handle session store errors
  sessionStore.on('error', (err: Error) => {
    console.error('Session store error:', err);
  });

  // Session middleware with PostgreSQL store
  app.use(
    session({
      store: sessionStore,
      secret: process.env.SESSION_SECRET || "operation-fiscal-freedom-secret-key-2024",
      resave: false,
      saveUninitialized: false,
      cookie: {
        secure: process.env.NODE_ENV === "production",
        httpOnly: true,
        sameSite: process.env.NODE_ENV === "production" ? 'none' : 'lax',
        maxAge: 24 * 60 * 60 * 1000, // 24 hours
      },
    })
  );

  // ===== PUBLIC ROUTES =====

  // Submit affiliate application (legacy - just stores application)
  app.post("/api/affiliate-applications", async (req, res) => {
    try {
      const data = insertAffiliateApplicationSchema.parse(req.body);
      const application = await storage.createAffiliateApplication(data);
      res.status(201).json({ success: true, id: application.id });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to submit application" });
    }
  });

  // New affiliate self-signup - creates account and logs in immediately
  app.post("/api/affiliate-signup", async (req, res) => {
    try {
      const { name, companyName, phone, email, password, description } = req.body;
      
      if (!name || !email || !password) {
        return res.status(400).json({ message: "Name, email, and password are required" });
      }
      
      if (password.length < 6) {
        return res.status(400).json({ message: "Password must be at least 6 characters" });
      }
      
      // Check if email already exists
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ message: "An account with this email already exists. Please login instead." });
      }
      
      // Create the affiliate user account
      const affiliate = await createAffiliateUser(name, email, password);
      
      // Also store the application info for admin reference
      try {
        await storage.createAffiliateApplication({
          name,
          companyName: companyName || "",
          phone: phone || "",
          email,
          description: description || "",
        });
      } catch (appError) {
        // Application storage is optional, don't fail the signup
        console.log("Note: Could not store application details:", appError);
      }
      
      // Log the user in automatically with session regeneration for security
      req.session.regenerate((regenerateErr) => {
        if (regenerateErr) {
          console.error("Session regenerate error:", regenerateErr);
          // Still return success since account was created
          return res.status(201).json({ 
            success: true,
            user: {
              id: affiliate.id, 
              name: affiliate.name, 
              email: affiliate.email, 
              role: affiliate.role 
            }
          });
        }
        
        req.session.userId = affiliate.id;
        req.session.userRole = affiliate.role;
        
        // Ensure session is saved before responding
        req.session.save((saveErr) => {
          if (saveErr) {
            console.error("Session save error:", saveErr);
          }
          console.log(`[auth] Affiliate signup successful for user ${affiliate.id}, session saved`);
          res.status(201).json({ 
            success: true,
            user: {
              id: affiliate.id, 
              name: affiliate.name, 
              email: affiliate.email, 
              role: affiliate.role 
            }
          });
        });
      });
    } catch (error) {
      console.error("Affiliate signup error:", error);
      res.status(500).json({ message: "Failed to create account. Please try again." });
    }
  });

  // Track referral link visit - locks IP to affiliate for 30 days (first-touch attribution)
  app.post("/api/track-referral", async (req, res) => {
    try {
      const { referralCode } = req.body;
      
      if (!referralCode) {
        return res.status(400).json({ message: "Referral code required" });
      }
      
      // Get client IP address
      const clientIp = req.headers['x-forwarded-for']?.toString().split(',')[0] || req.socket.remoteAddress || 'unknown';
      
      // Check if this IP is already tracked
      const existingTracking = await storage.getActiveIpReferral(clientIp);
      if (existingTracking) {
        // IP already tracked - return existing affiliate info (first-touch attribution)
        return res.json({ 
          success: true, 
          message: "IP already attributed",
          referralCode: existingTracking.referralCode,
          expiresAt: existingTracking.expiresAt
        });
      }
      
      // Look up affiliate by referral code
      const affiliate = await storage.getUserByReferralCode(referralCode);
      if (!affiliate) {
        return res.status(404).json({ message: "Invalid referral code" });
      }
      
      // Create IP tracking record (30 day expiration)
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 30);
      
      await storage.createIpReferralTracking({
        ipAddress: clientIp,
        affiliateId: affiliate.id,
        referralCode: referralCode,
        expiresAt,
      });
      
      res.json({ 
        success: true, 
        message: "Referral tracked",
        referralCode,
        expiresAt
      });
    } catch (error) {
      console.error("Error tracking referral:", error);
      res.status(500).json({ message: "Failed to track referral" });
    }
  });

  // ===== FIN-OPS PARTNER TRACKING =====
  
  // Partner service URLs mapping
  const FINOPS_PARTNER_URLS: Record<string, string> = {
    my_locker: "https://www.moq1.com/imaginate-pod/navigatorusa",
    merchant_services: "https://staging.fluidfintec.com/merchant-signup",
    vgift_cards: "https://ptogiftcardprogram.com/navigator-usa-virtual-gift-cards/?group="
  };

  // Zod schema for finops track-click validation
  const trackClickSchema = z.object({
    partnerType: z.enum(["my_locker", "merchant_services", "vgift_cards"]),
    referralCode: z.string().optional().nullable()
  });

  // Track finops partner click and redirect
  app.post("/api/finops/track-click", async (req, res) => {
    try {
      const validationResult = trackClickSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({ message: "Invalid request body", errors: validationResult.error.errors });
      }
      
      const { partnerType, referralCode } = validationResult.data;
      
      if (!FINOPS_PARTNER_URLS[partnerType]) {
        return res.status(400).json({ message: "Invalid partner type" });
      }
      
      const clientIp = req.headers['x-forwarded-for']?.toString().split(',')[0] || req.socket.remoteAddress || 'unknown';
      const userAgent = req.headers['user-agent'] || 'unknown';
      const externalUrl = FINOPS_PARTNER_URLS[partnerType];
      
      // Look up affiliate by referral code if provided
      let affiliateId: number | undefined;
      if (referralCode) {
        const affiliate = await storage.getUserByReferralCode(referralCode);
        if (affiliate) {
          affiliateId = affiliate.id;
        }
      }
      
      // Create tracking record
      const referral = await storage.createFinopsReferral({
        affiliateId: affiliateId || null,
        referralCode: referralCode || null,
        partnerType,
        externalUrl,
        visitorIp: clientIp,
        userAgent
      });
      
      console.log(`[finops] Tracked ${partnerType} click - ref: ${referralCode || 'direct'}, ip: ${clientIp}`);
      
      res.json({ 
        success: true, 
        trackingId: referral.id,
        redirectUrl: externalUrl
      });
    } catch (error) {
      console.error("Error tracking finops click:", error);
      res.status(500).json({ message: "Failed to track click" });
    }
  });

  // Get all finops referrals (admin/master only)
  app.get("/api/admin/finops-referrals", async (req, res) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    const user = await storage.getUser(req.session.userId);
    if (!user || (user.role !== "admin" && user.role !== "master")) {
      return res.status(403).json({ message: "Admin access required" });
    }
    
    try {
      const referrals = await storage.getAllFinopsReferrals();
      
      // Enrich with affiliate names
      const enrichedReferrals = await Promise.all(referrals.map(async (r) => {
        let affiliateName = null;
        if (r.affiliateId) {
          const affiliate = await storage.getUser(r.affiliateId);
          affiliateName = affiliate?.name || null;
        }
        return { ...r, affiliateName };
      }));
      
      res.json(enrichedReferrals);
    } catch (error) {
      console.error("Error fetching finops referrals:", error);
      res.status(500).json({ message: "Failed to fetch referrals" });
    }
  });

  // Update finops referral status (admin/master only)
  app.patch("/api/admin/finops-referrals/:id", async (req, res) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    const user = await storage.getUser(req.session.userId);
    if (!user || (user.role !== "admin" && user.role !== "master")) {
      return res.status(403).json({ message: "Admin access required" });
    }
    
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateFinopsReferral(id, req.body);
      if (!updated) {
        return res.status(404).json({ message: "Referral not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating finops referral:", error);
      res.status(500).json({ message: "Failed to update referral" });
    }
  });

  // ============================================
  // DISABILITY REFERRAL TRACKING ENDPOINTS
  // ============================================

  // Submit disability referral (public endpoint)
  app.post("/api/disability-referrals", async (req, res) => {
    try {
      const data = insertDisabilityReferralSchema.parse(req.body);
      
      // Get client IP and user agent
      const clientIp = req.headers['x-forwarded-for']?.toString().split(',')[0] || req.socket.remoteAddress || 'unknown';
      const userAgent = req.headers['user-agent'] || 'unknown';
      
      // Look up affiliate by referral code if provided
      let affiliateId: number | undefined;
      if (data.referralCode) {
        const affiliate = await storage.getUserByReferralCode(data.referralCode);
        if (affiliate) {
          affiliateId = affiliate.id;
        }
      }
      
      const referral = await storage.createDisabilityReferral({
        ...data,
        affiliateId,
        visitorIp: clientIp,
        userAgent,
      });
      
      console.log(`[disability] New ${data.claimType} referral - ref: ${data.referralCode || 'direct'}, email: ${data.email}`);
      
      res.status(201).json({ 
        message: "Referral submitted successfully", 
        id: referral.id 
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid form data", errors: error.errors });
      }
      console.error("Error creating disability referral:", error);
      res.status(500).json({ message: "Failed to submit referral" });
    }
  });

  // Submit job placement intake (public endpoint)
  app.post("/api/job-placement-intakes", async (req, res) => {
    try {
      const data = insertJobPlacementIntakeSchema.parse(req.body);
      
      // Look up affiliate by referral code if provided
      let affiliateId: number | undefined;
      if (data.referralCode) {
        const affiliate = await storage.getUserByReferralCode(data.referralCode);
        if (affiliate) {
          affiliateId = affiliate.id;
        }
      }
      
      const intake = await storage.createJobPlacementIntake({
        ...data,
        affiliateId,
      });
      
      console.log(`[job-placement] New ${data.intakeType} intake - ref: ${data.referralCode || 'direct'}, email: ${data.email}`);
      
      res.status(201).json({ 
        message: "Application submitted successfully", 
        id: intake.id 
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid form data", errors: error.errors });
      }
      console.error("Error creating job placement intake:", error);
      res.status(500).json({ message: "Failed to submit application" });
    }
  });

  // Get all job placement intakes (admin/master only)
  app.get("/api/admin/job-placement-intakes", async (req, res) => {
    if (!req.session.userId || (req.session.userRole !== "admin" && req.session.userRole !== "master")) {
      return res.status(403).json({ message: "Forbidden - Admin access required" });
    }
    
    try {
      const intakes = await storage.getAllJobPlacementIntakes();
      res.json(intakes);
    } catch (error) {
      console.error("Error fetching job placement intakes:", error);
      res.status(500).json({ message: "Failed to fetch intakes" });
    }
  });

  // Update job placement intake (admin/master only)
  app.patch("/api/admin/job-placement-intakes/:id", async (req, res) => {
    if (!req.session.userId || (req.session.userRole !== "admin" && req.session.userRole !== "master")) {
      return res.status(403).json({ message: "Forbidden - Admin access required" });
    }
    
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateJobPlacementIntake(id, req.body);
      if (!updated) {
        return res.status(404).json({ message: "Intake not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating job placement intake:", error);
      res.status(500).json({ message: "Failed to update intake" });
    }
  });

  // Vet Professional Intakes
  app.post("/api/vet-professional-intakes", async (req, res) => {
    try {
      const intake = await storage.createVetProfessionalIntake(req.body);
      res.status(201).json(intake);
    } catch (error) {
      console.error("Error creating vet professional intake:", error);
      res.status(500).json({ message: "Failed to submit intake" });
    }
  });

  app.get("/api/admin/vet-professional-intakes", async (req, res) => {
    if (!req.session.userId || (req.session.userRole !== "admin" && req.session.userRole !== "master")) {
      return res.status(403).json({ message: "Forbidden - Admin access required" });
    }
    
    try {
      const intakes = await storage.getAllVetProfessionalIntakes();
      res.json(intakes);
    } catch (error) {
      console.error("Error fetching vet professional intakes:", error);
      res.status(500).json({ message: "Failed to fetch intakes" });
    }
  });

  app.patch("/api/admin/vet-professional-intakes/:id", async (req, res) => {
    if (!req.session.userId || (req.session.userRole !== "admin" && req.session.userRole !== "master")) {
      return res.status(403).json({ message: "Forbidden - Admin access required" });
    }
    
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateVetProfessionalIntake(id, req.body);
      if (!updated) {
        return res.status(404).json({ message: "Intake not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating vet professional intake:", error);
      res.status(500).json({ message: "Failed to update intake" });
    }
  });

  // Healthcare Intakes - public submission
  app.post("/api/healthcare-intakes", async (req, res) => {
    try {
      const intake = await storage.createHealthcareIntake(req.body);
      res.status(201).json(intake);
    } catch (error) {
      console.error("Error creating healthcare intake:", error);
      res.status(500).json({ message: "Failed to submit intake" });
    }
  });

  // Healthcare Intakes - master portal only
  app.get("/api/admin/healthcare-intakes", async (req, res) => {
    if (!req.session.userId || (req.session.userRole !== "admin" && req.session.userRole !== "master")) {
      return res.status(403).json({ message: "Forbidden - Master access required" });
    }
    
    try {
      const intakes = await storage.getAllHealthcareIntakes();
      res.json(intakes);
    } catch (error) {
      console.error("Error fetching healthcare intakes:", error);
      res.status(500).json({ message: "Failed to fetch intakes" });
    }
  });

  app.patch("/api/admin/healthcare-intakes/:id", async (req, res) => {
    if (!req.session.userId || (req.session.userRole !== "admin" && req.session.userRole !== "master")) {
      return res.status(403).json({ message: "Forbidden - Master access required" });
    }
    
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateHealthcareIntake(id, req.body);
      if (!updated) {
        return res.status(404).json({ message: "Intake not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating healthcare intake:", error);
      res.status(500).json({ message: "Failed to update intake" });
    }
  });

  // Get all disability referrals (admin/master only)
  app.get("/api/admin/disability-referrals", async (req, res) => {
    if (!req.session.userId || (req.session.userRole !== "admin" && req.session.userRole !== "master")) {
      return res.status(403).json({ message: "Forbidden - Admin access required" });
    }
    
    try {
      const referrals = await storage.getAllDisabilityReferrals();
      res.json(referrals);
    } catch (error) {
      console.error("Error fetching disability referrals:", error);
      res.status(500).json({ message: "Failed to fetch referrals" });
    }
  });

  // Get disability referrals for a specific affiliate
  app.get("/api/affiliate/disability-referrals", async (req, res) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    try {
      const referrals = await storage.getDisabilityReferralsByAffiliate(req.session.userId);
      res.json(referrals);
    } catch (error) {
      console.error("Error fetching affiliate disability referrals:", error);
      res.status(500).json({ message: "Failed to fetch referrals" });
    }
  });

  // Get vet professional intakes for affiliate
  app.get("/api/affiliate/vet-professional-intakes", async (req, res) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    try {
      const intakes = await storage.getVetProfessionalIntakesByAffiliate(req.session.userId);
      res.json(intakes);
    } catch (error) {
      console.error("Error fetching affiliate vet professional intakes:", error);
      res.status(500).json({ message: "Failed to fetch intakes" });
    }
  });

  // Update disability referral status (admin/master only)
  app.patch("/api/admin/disability-referrals/:id", async (req, res) => {
    if (!req.session.userId || (req.session.userRole !== "admin" && req.session.userRole !== "master")) {
      return res.status(403).json({ message: "Forbidden - Admin access required" });
    }
    
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateDisabilityReferral(id, req.body);
      if (!updated) {
        return res.status(404).json({ message: "Referral not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating disability referral:", error);
      res.status(500).json({ message: "Failed to update referral" });
    }
  });

  // Get disability referral stats (admin/master only)
  app.get("/api/admin/disability-referrals/stats", async (req, res) => {
    if (!req.session.userId || (req.session.userRole !== "admin" && req.session.userRole !== "master")) {
      return res.status(403).json({ message: "Forbidden - Admin access required" });
    }
    
    try {
      const stats = await storage.getDisabilityReferralStats();
      res.json(stats);
    } catch (error) {
      console.error("Error fetching disability referral stats:", error);
      res.status(500).json({ message: "Failed to fetch stats" });
    }
  });

  // Submit help request
  app.post("/api/help-requests", async (req, res) => {
    try {
      const { referralCode, ...rest } = req.body;
      const data = insertHelpRequestSchema.parse(rest);
      
      // Get client IP address
      const clientIp = req.headers['x-forwarded-for']?.toString().split(',')[0] || req.socket.remoteAddress || 'unknown';
      
      // Look up affiliate by referral code if provided, or check IP tracking
      let referredById: number | undefined;
      let finalReferralCode = referralCode;
      
      if (referralCode) {
        // Referral code provided - use it and track IP
        const affiliate = await storage.getUserByReferralCode(referralCode);
        if (affiliate) {
          referredById = affiliate.id;
          // Track this IP if not already tracked
          const existingIpTracking = await storage.getActiveIpReferral(clientIp);
          if (!existingIpTracking) {
            const expiresAt = new Date();
            expiresAt.setDate(expiresAt.getDate() + 30); // 30 day expiration
            await storage.createIpReferralTracking({
              ipAddress: clientIp,
              affiliateId: affiliate.id,
              referralCode: referralCode,
              expiresAt,
            });
          }
        }
      } else {
        // No referral code - check if IP is already tracked
        const ipTracking = await storage.getActiveIpReferral(clientIp);
        if (ipTracking && ipTracking.affiliateId) {
          referredById = ipTracking.affiliateId;
          finalReferralCode = ipTracking.referralCode;
        }
      }
      
      const request = await storage.createHelpRequest({
        ...data,
        referralCode: finalReferralCode || undefined,
        referredBy: referredById,
      } as any);
      res.status(201).json({ success: true, id: request.id });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to submit request" });
    }
  });

  // Submit startup grant application
  app.post("/api/startup-grants", async (req, res) => {
    try {
      const data = insertStartupGrantSchema.parse(req.body);
      const grant = await storage.createStartupGrant(data);
      res.status(201).json({ success: true, id: grant.id });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to submit grant application" });
    }
  });

  // Submit furniture assistance request
  app.post("/api/furniture-assistance", async (req, res) => {
    try {
      const data = insertFurnitureAssistanceSchema.parse(req.body);
      const request = await storage.createFurnitureAssistance(data);
      res.status(201).json({ success: true, id: request.id });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to submit furniture assistance request" });
    }
  });

  // Submit investor submission
  app.post("/api/investor-submissions", async (req, res) => {
    try {
      const data = insertInvestorSubmissionSchema.parse(req.body);
      const submission = await storage.createInvestorSubmission(data);
      res.status(201).json({ success: true, id: submission.id });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to submit investor information" });
    }
  });

  // Submit private doctor request
  app.post("/api/private-doctor-requests", async (req, res) => {
    try {
      const data = insertPrivateDoctorRequestSchema.parse(req.body);
      const request = await storage.createPrivateDoctorRequest(data);
      res.status(201).json({ success: true, id: request.id });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to submit private doctor request" });
    }
  });

  // Submit website application
  app.post("/api/website-applications", async (req, res) => {
    try {
      const data = insertWebsiteApplicationSchema.parse(req.body);
      const application = await storage.createWebsiteApplication(data);
      res.status(201).json({ success: true, id: application.id });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to submit website application" });
    }
  });

  // Submit general contact
  app.post("/api/general-contact", async (req, res) => {
    try {
      const data = insertGeneralContactSchema.parse(req.body);
      const contact = await storage.createGeneralContact(data);
      res.status(201).json({ success: true, id: contact.id });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to submit contact form" });
    }
  });

  // Submit VLT intake
  app.post("/api/vlt-intake", async (req, res) => {
    try {
      const data = insertVltIntakeSchema.parse(req.body);
      
      // Look up referral code if provided
      let referralData: any = {};
      if (data.referralCode) {
        const affiliate = await storage.getVltAffiliateByReferralCode(data.referralCode);
        if (affiliate) {
          referralData = {
            referredByL1: affiliate.id,
            referredByL2: affiliate.level1Id,
            referredByL3: affiliate.level2Id,
            referredByL4: affiliate.level3Id,
            referredByL5: affiliate.level4Id,
            referredByL6: affiliate.level5Id,
          };
          // Increment affiliate's lead count
          await storage.updateVltAffiliate(affiliate.id, { 
            totalLeads: (affiliate.totalLeads || 0) + 1 
          });
        }
      }
      
      const intake = await storage.createVltIntake({ ...data, ...referralData });
      
      // Forward to CRM webhook if configured
      if (process.env.CRM_WEBHOOK_URL) {
        fetch(process.env.CRM_WEBHOOK_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ ...data, routedTo: intake.routedTo }),
        }).catch(err => console.error("CRM webhook failed:", err));
      }
      
      res.status(201).json({ success: true, id: intake.id, routedTo: intake.routedTo });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to submit intake form" });
    }
  });

  // CRM webhook forwarder
  app.post("/api/crm-webhook", async (req, res) => {
    try {
      if (!process.env.CRM_WEBHOOK_URL) {
        return res.status(500).json({ message: "CRM webhook not configured" });
      }
      
      await fetch(process.env.CRM_WEBHOOK_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(req.body),
      });
      
      res.json({ ok: true });
    } catch (error) {
      res.status(500).json({ message: "Webhook forwarding failed" });
    }
  });

  // Process lead (CRM + notify)
  app.post("/api/process-lead", async (req, res) => {
    try {
      const data = req.body;
      
      // Forward to CRM
      if (process.env.CRM_WEBHOOK_URL) {
        fetch(process.env.CRM_WEBHOOK_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(data),
        }).catch(err => console.error("CRM webhook failed:", err));
      }
      
      // Send notifications
      if (process.env.RESEND_API_KEY && data.email) {
        const resend = new Resend(process.env.RESEND_API_KEY);
        resend.emails.send({
          from: "Veteran Led Tax Solutions <no-reply@veteranledtax.com>",
          to: data.email,
          subject: "We received your intake",
          html: `<p>Your intake was received. A specialist will review shortly.</p>`,
        }).catch(err => console.error("Email failed:", err));
      }
      
      if (process.env.TWILIO_ACCOUNT_SID && data.phone) {
        const tw = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN!);
        tw.messages.create({
          to: data.phone,
          from: process.env.TWILIO_FROM!,
          body: "Your intake was received. A specialist will review shortly.",
        }).catch(err => console.error("SMS failed:", err));
      }
      
      res.json({ ok: true });
    } catch (error) {
      console.error("Process lead error:", error);
      res.status(500).json({ message: "Failed to process lead" });
    }
  });

  // Stripe checkout session
  app.post("/api/checkout", async (req, res) => {
    try {
      if (!process.env.STRIPE_SECRET_KEY) {
        return res.status(500).json({ message: "Stripe not configured" });
      }
      
      const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
      const session = await stripe.checkout.sessions.create({
        mode: "payment",
        payment_method_types: ["card"],
        line_items: [{
          price_data: {
            currency: "usd",
            product_data: { name: "Professional Review Fee" },
            unit_amount: 5000,
          },
          quantity: 1,
        }],
        success_url: `${req.headers.origin}/veteran-led-tax?paid=true`,
        cancel_url: `${req.headers.origin}/veteran-led-tax?canceled=true`,
      });
      
      res.json({ url: session.url });
    } catch (error) {
      console.error("Stripe error:", error);
      res.status(500).json({ message: "Failed to create checkout session" });
    }
  });

  // Send notifications (email + SMS)
  app.post("/api/notify", async (req, res) => {
    try {
      const { email, phone, message } = req.body;

      // Send email via Resend if configured
      if (process.env.RESEND_API_KEY && email) {
        const resend = new Resend(process.env.RESEND_API_KEY);
        await resend.emails.send({
          from: "Veteran Led Tax Solutions <no-reply@veteranledtax.com>",
          to: email,
          subject: "We received your intake",
          html: `<p>${message || "Your intake was received. A specialist will review shortly."}</p>`,
        });
      }

      // Send SMS via Twilio if configured
      if (process.env.TWILIO_ACCOUNT_SID && process.env.TWILIO_AUTH_TOKEN && phone) {
        const tw = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);
        await tw.messages.create({
          to: phone,
          from: process.env.TWILIO_FROM!,
          body: "Your intake was received. A specialist will review shortly.",
        });
      }

      res.json({ ok: true });
    } catch (error) {
      console.error("Notification error:", error);
      res.status(500).json({ message: "Failed to send notification" });
    }
  });

  // Get all VLT intakes (admin)
  app.get("/api/admin/vlt-intake", requireAdmin, async (req, res) => {
    try {
      const intakes = await storage.getAllVltIntakes();
      res.json(intakes);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch VLT intakes" });
    }
  });

  // Update VLT intake (admin)
  app.patch("/api/admin/vlt-intake/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateVltIntake(id, req.body);
      if (!updated) {
        return res.status(404).json({ message: "Intake not found" });
      }
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update VLT intake" });
    }
  });

  // ===== VLT AFFILIATE MANAGEMENT (Admin) =====
  
  // Get all VLT affiliates
  app.get("/api/admin/vlt-affiliates", requireAdmin, async (req, res) => {
    try {
      const affiliates = await storage.getAllVltAffiliates();
      res.json(affiliates);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch VLT affiliates" });
    }
  });

  // Create VLT affiliate
  app.post("/api/admin/vlt-affiliates", requireAdmin, async (req, res) => {
    try {
      const { name, email, phone, password, uplineCode } = req.body;
      
      // Generate unique referral code
      const referralCode = `VLT${Date.now().toString(36).toUpperCase()}`;
      
      // Hash password
      const bcrypt = await import("bcrypt");
      const passwordHash = await bcrypt.hash(password, 10);
      
      // Look up upline if provided
      let uplineData: any = {};
      if (uplineCode) {
        const upline = await storage.getVltAffiliateByReferralCode(uplineCode);
        if (upline) {
          uplineData = {
            level1Id: upline.id,
            level2Id: upline.level1Id,
            level3Id: upline.level2Id,
            level4Id: upline.level3Id,
            level5Id: upline.level4Id,
            level6Id: upline.level5Id,
          };
        }
      }
      
      const affiliate = await storage.createVltAffiliate({
        name,
        email,
        phone,
        passwordHash,
        referralCode,
        status: "active",
        ...uplineData,
      });
      
      res.status(201).json(affiliate);
    } catch (error) {
      console.error("Create affiliate error:", error);
      res.status(500).json({ message: "Failed to create VLT affiliate" });
    }
  });

  // Update VLT affiliate
  app.patch("/api/admin/vlt-affiliates/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateVltAffiliate(id, req.body);
      if (!updated) {
        return res.status(404).json({ message: "Affiliate not found" });
      }
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update VLT affiliate" });
    }
  });

  // Delete VLT affiliate
  app.delete("/api/admin/vlt-affiliates/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteVltAffiliate(id);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete VLT affiliate" });
    }
  });

  // ===== VLT AFFILIATE PORTAL =====
  
  // VLT Affiliate login
  app.post("/api/vlt-affiliate/login", async (req, res) => {
    try {
      const { email, password } = req.body;
      const affiliate = await storage.getVltAffiliateByEmail(email);
      
      if (!affiliate) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      
      const bcrypt = await import("bcrypt");
      const valid = await bcrypt.compare(password, affiliate.passwordHash);
      
      if (!valid) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      
      // Regenerate session to prevent session fixation and ensure clean session
      req.session.regenerate((regenerateErr) => {
        if (regenerateErr) {
          console.error("VLT session regenerate error:", regenerateErr);
          return res.status(500).json({ message: "Login failed - session error" });
        }
        
        req.session.vltAffiliateId = affiliate.id;
        
        // Ensure session is saved before responding
        req.session.save((saveErr) => {
          if (saveErr) {
            console.error("VLT session save error:", saveErr);
            return res.status(500).json({ message: "Login failed - session error" });
          }
          console.log(`[auth] VLT login successful for affiliate ${affiliate.id}, session saved`);
          res.json({ 
            success: true, 
            affiliate: { 
              id: affiliate.id, 
              name: affiliate.name, 
              email: affiliate.email,
              referralCode: affiliate.referralCode,
              totalLeads: affiliate.totalLeads
            }
          });
        });
      });
    } catch (error) {
      console.error("VLT login error:", error);
      res.status(500).json({ message: "Login failed" });
    }
  });

  // VLT Affiliate logout
  app.post("/api/vlt-affiliate/logout", (req, res) => {
    req.session.vltAffiliateId = undefined;
    res.json({ success: true });
  });

  // Get current VLT affiliate
  app.get("/api/vlt-affiliate/me", async (req, res) => {
    try {
      if (!req.session.vltAffiliateId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const affiliate = await storage.getVltAffiliate(req.session.vltAffiliateId);
      if (!affiliate) {
        return res.status(404).json({ message: "Affiliate not found" });
      }
      // Calculate upline count
      let uplineCount = 0;
      if (affiliate.level1Id) uplineCount++;
      if (affiliate.level2Id) uplineCount++;
      if (affiliate.level3Id) uplineCount++;
      if (affiliate.level4Id) uplineCount++;
      if (affiliate.level5Id) uplineCount++;
      if (affiliate.level6Id) uplineCount++;

      res.json({
        id: affiliate.id,
        name: affiliate.name,
        email: affiliate.email,
        referralCode: affiliate.referralCode,
        role: affiliate.role,
        totalLeads: affiliate.totalLeads,
        totalSales: affiliate.totalSales,
        totalCommissions: affiliate.totalCommissions,
        status: affiliate.status,
        uplineCount,
        level1Id: affiliate.level1Id,
        level2Id: affiliate.level2Id,
        level3Id: affiliate.level3Id,
        level4Id: affiliate.level4Id,
        level5Id: affiliate.level5Id,
        level6Id: affiliate.level6Id,
        recruiterId: affiliate.recruiterId
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to get affiliate" });
    }
  });

  // Get VLT affiliate's leads
  app.get("/api/vlt-affiliate/leads", async (req, res) => {
    try {
      if (!req.session.vltAffiliateId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const leads = await storage.getVltIntakesByAffiliate(req.session.vltAffiliateId);
      res.json(leads);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch leads" });
    }
  });

  // ===== AUTH ROUTES =====

  // Login
  app.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password } = req.body;
      
      if (!email || !password) {
        return res.status(400).json({ message: "Email and password are required" });
      }

      const user = await authenticateUser(email, password);
      if (!user) {
        return res.status(401).json({ message: "Invalid email or password" });
      }

      // Regenerate session to prevent session fixation attacks and ensure clean session
      req.session.regenerate((regenerateErr) => {
        if (regenerateErr) {
          console.error("Session regenerate error:", regenerateErr);
          return res.status(500).json({ message: "Login failed - session error" });
        }
        
        req.session.userId = user.id;
        req.session.userRole = user.role;

        // Ensure session is saved before responding
        req.session.save((saveErr) => {
          if (saveErr) {
            console.error("Session save error:", saveErr);
            return res.status(500).json({ message: "Login failed - session error" });
          }
          console.log(`[auth] Login successful for user ${user.id}, session saved`);
          res.json({ 
            success: true, 
            user: { id: user.id, name: user.name, email: user.email, role: user.role }
          });
        });
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "Login failed" });
    }
  });

  // Logout
  app.post("/api/auth/logout", (req, res) => {
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ message: "Logout failed" });
      }
      res.json({ success: true });
    });
  });

  // Get current user
  app.get("/api/auth/me", async (req, res) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }

    const user = await storage.getUser(req.session.userId);
    if (!user) {
      return res.status(401).json({ message: "User not found" });
    }

    res.json({ 
      user: { id: user.id, name: user.name, email: user.email, role: user.role }
    });
  });

  // Initialize admin (one-time setup)
  app.post("/api/auth/init-admin", async (req, res) => {
    try {
      const { name, email, password, setupKey } = req.body;
      
      // Use environment variable for setup key, fallback only in development
      const expectedSetupKey = process.env.ADMIN_SETUP_KEY || (process.env.NODE_ENV !== "production" ? "OFF2024SETUP" : null);
      
      if (!expectedSetupKey || setupKey !== expectedSetupKey) {
        return res.status(403).json({ message: "Invalid setup key" });
      }

      // Check if admin already exists
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ message: "User already exists" });
      }

      const admin = await createAdminUser(name, email, password);
      res.status(201).json({ 
        success: true, 
        user: { id: admin.id, name: admin.name, email: admin.email, role: admin.role }
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to create admin" });
    }
  });

  // Register new user (public registration)
  app.post("/api/auth/register", async (req, res) => {
    try {
      const { name, email, password, branchOfService } = req.body;
      
      if (!name || !email || !password) {
        return res.status(400).json({ message: "Name, email, and password are required" });
      }

      // Check if user already exists
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ message: "An account with this email already exists" });
      }

      // Create user with affiliate role by default
      const bcrypt = await import("bcrypt");
      const passwordHash = await bcrypt.hash(password, 10);
      const user = await storage.createUser({
        name,
        email,
        passwordHash,
        role: "affiliate"
      });

      // Auto-login after registration with session regeneration for security
      req.session.regenerate((regenerateErr) => {
        if (regenerateErr) {
          console.error("Registration session regenerate error:", regenerateErr);
          // Still return success since account was created
          return res.status(201).json({ 
            success: true, 
            user: { id: user.id, name: user.name, email: user.email, role: user.role }
          });
        }
        
        req.session.userId = user.id;
        req.session.userRole = user.role;

        // Ensure session is saved before responding
        req.session.save((saveErr) => {
          if (saveErr) {
            console.error("Registration session save error:", saveErr);
          }
          console.log(`[auth] Registration successful for user ${user.id}, session saved`);
          res.status(201).json({ 
            success: true, 
            user: { id: user.id, name: user.name, email: user.email, role: user.role }
          });
        });
      });
    } catch (error) {
      console.error("Registration error:", error);
      res.status(500).json({ message: "Failed to create account" });
    }
  });

  // ===== ADMIN ROUTES =====

  // Get all affiliate applications
  app.get("/api/admin/affiliate-applications", requireAdmin, async (req, res) => {
    try {
      const applications = await storage.getAllAffiliateApplications();
      res.json(applications);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch applications" });
    }
  });

  // Get all help requests
  app.get("/api/admin/help-requests", requireAdmin, async (req, res) => {
    try {
      const requests = await storage.getAllHelpRequests();
      res.json(requests);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch requests" });
    }
  });

  // Update affiliate application
  app.patch("/api/admin/affiliate-applications/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const application = await storage.updateAffiliateApplication(id, updates);
      
      if (!application) {
        return res.status(404).json({ message: "Application not found" });
      }
      
      res.json(application);
    } catch (error) {
      res.status(500).json({ message: "Failed to update application" });
    }
  });

  // Update help request
  app.patch("/api/admin/help-requests/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const request = await storage.updateHelpRequest(id, updates);
      
      if (!request) {
        return res.status(404).json({ message: "Request not found" });
      }
      
      res.json(request);
    } catch (error) {
      res.status(500).json({ message: "Failed to update request" });
    }
  });

  // Get all affiliates
  app.get("/api/admin/affiliates", requireAdmin, async (req, res) => {
    try {
      const affiliates = await storage.getAllAffiliates();
      res.json(affiliates.map(a => ({ 
        id: a.id, 
        name: a.name, 
        email: a.email, 
        role: a.role,
        createdAt: a.createdAt 
      })));
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch affiliates" });
    }
  });

  // Create affiliate user
  app.post("/api/admin/affiliates", requireAdmin, async (req, res) => {
    try {
      const { name, email, password } = req.body;
      
      if (!name || !email || !password) {
        return res.status(400).json({ message: "Name, email, and password are required" });
      }

      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ message: "User with this email already exists" });
      }

      const affiliate = await createAffiliateUser(name, email, password);
      res.status(201).json({ 
        id: affiliate.id, 
        name: affiliate.name, 
        email: affiliate.email, 
        role: affiliate.role 
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to create affiliate" });
    }
  });

  // Reset affiliate password
  app.patch("/api/admin/affiliates/:id/password", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { password } = req.body;
      
      if (!password) {
        return res.status(400).json({ message: "Password is required" });
      }

      const passwordHash = await hashPassword(password);
      const user = await storage.updateUserPassword(id, passwordHash);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to reset password" });
    }
  });

  // Delete affiliate
  app.delete("/api/admin/affiliates/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteUser(id);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete affiliate" });
    }
  });

  // Get all startup grants
  app.get("/api/admin/startup-grants", requireAdmin, async (req, res) => {
    try {
      const grants = await storage.getAllStartupGrants();
      res.json(grants);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch startup grants" });
    }
  });

  // Update startup grant
  app.patch("/api/admin/startup-grants/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const grant = await storage.updateStartupGrant(id, updates);
      
      if (!grant) {
        return res.status(404).json({ message: "Grant not found" });
      }
      
      res.json(grant);
    } catch (error) {
      res.status(500).json({ message: "Failed to update grant" });
    }
  });

  // Get all furniture assistance requests
  app.get("/api/admin/furniture-assistance", requireAdmin, async (req, res) => {
    try {
      const requests = await storage.getAllFurnitureAssistance();
      res.json(requests);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch furniture assistance requests" });
    }
  });

  // Update furniture assistance
  app.patch("/api/admin/furniture-assistance/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const request = await storage.updateFurnitureAssistance(id, updates);
      
      if (!request) {
        return res.status(404).json({ message: "Request not found" });
      }
      
      res.json(request);
    } catch (error) {
      res.status(500).json({ message: "Failed to update furniture assistance request" });
    }
  });

  // Get all investor submissions
  app.get("/api/admin/investor-submissions", requireAdmin, async (req, res) => {
    try {
      const submissions = await storage.getAllInvestorSubmissions();
      res.json(submissions);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch investor submissions" });
    }
  });

  // Update investor submission
  app.patch("/api/admin/investor-submissions/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const submission = await storage.updateInvestorSubmission(id, updates);
      
      if (!submission) {
        return res.status(404).json({ message: "Submission not found" });
      }
      
      res.json(submission);
    } catch (error) {
      res.status(500).json({ message: "Failed to update investor submission" });
    }
  });

  // Get all private doctor requests
  app.get("/api/admin/private-doctor-requests", requireAdmin, async (req, res) => {
    try {
      const requests = await storage.getAllPrivateDoctorRequests();
      res.json(requests);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch private doctor requests" });
    }
  });

  // Update private doctor request
  app.patch("/api/admin/private-doctor-requests/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const request = await storage.updatePrivateDoctorRequest(id, updates);
      
      if (!request) {
        return res.status(404).json({ message: "Request not found" });
      }
      
      res.json(request);
    } catch (error) {
      res.status(500).json({ message: "Failed to update private doctor request" });
    }
  });

  // Get all website applications
  app.get("/api/admin/website-applications", requireAdmin, async (req, res) => {
    try {
      const applications = await storage.getAllWebsiteApplications();
      res.json(applications);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch website applications" });
    }
  });

  // Update website application
  app.patch("/api/admin/website-applications/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const application = await storage.updateWebsiteApplication(id, updates);
      
      if (!application) {
        return res.status(404).json({ message: "Application not found" });
      }
      
      res.json(application);
    } catch (error) {
      res.status(500).json({ message: "Failed to update website application" });
    }
  });

  // Get all general contacts
  app.get("/api/admin/general-contact", requireAdmin, async (req, res) => {
    try {
      const contacts = await storage.getAllGeneralContacts();
      res.json(contacts);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch general contacts" });
    }
  });

  // Update general contact
  app.patch("/api/admin/general-contact/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const contact = await storage.updateGeneralContact(id, updates);
      
      if (!contact) {
        return res.status(404).json({ message: "Contact not found" });
      }
      
      res.json(contact);
    } catch (error) {
      res.status(500).json({ message: "Failed to update general contact" });
    }
  });

  // ===== MASTER PORTAL ROUTES (Admin Only) =====

  // Get all affiliate files/documents for master portal
  app.get("/api/master/affiliate-files", requireAdmin, async (req, res) => {
    try {
      // Get ALL signed NDAs directly from the affiliate_nda table
      const allNdas = await storage.getAllAffiliateNdas();
      console.log("[DEBUG] affiliate-files: Found", allNdas.length, "signed NDAs");
      
      // Get all affiliates for contracts and W9
      const affiliates = await storage.getAllAffiliates();
      console.log("[DEBUG] affiliate-files: Found", affiliates.length, "affiliates");
      
      // Create a combined result map keyed by user ID
      const resultMap = new Map<number, {
        id: number;
        name: string;
        email: string;
        nda?: any;
        contracts?: any[];
        w9?: any;
      }>();
      
      // First, add all NDAs (this ensures ALL signed NDAs appear regardless of user role)
      for (const nda of allNdas) {
        // Try to get user info, fall back to NDA data if user doesn't exist
        const user = await storage.getUser(nda.userId);
        resultMap.set(nda.userId, {
          id: nda.userId,
          name: user?.name || nda.fullName,
          email: user?.email || 'Unknown',
          nda: {
            id: nda.id,
            fullName: nda.fullName,
            address: nda.address,
            facePhoto: nda.facePhoto,
            idPhoto: nda.idPhoto,
            signatureData: nda.signatureData,
            signedAt: nda.signedAt,
          },
        });
      }
      
      // Then, add/merge affiliate data (contracts, W9)
      await Promise.all(
        affiliates.map(async (affiliate) => {
          const signedContracts = await storage.getSignedAgreementsByAffiliate(affiliate.id);
          const w9 = await storage.getAffiliateW9ByUserId(affiliate.id);
          
          // Get contract template names
          const contractsWithNames = await Promise.all(
            signedContracts.map(async (contract: { id: number; contractTemplateId: number; signatureData: string | null; createdAt: Date | null }) => {
              const template = await storage.getContractTemplate(contract.contractTemplateId);
              return {
                id: contract.id,
                contractName: template?.name || 'Unknown Contract',
                signedAt: contract.createdAt,
                signatureData: contract.signatureData,
              };
            })
          );
          
          // Check if this affiliate already exists in result (from NDA)
          const existing = resultMap.get(affiliate.id);
          if (existing) {
            // Merge contracts and W9
            existing.contracts = contractsWithNames.length > 0 ? contractsWithNames : undefined;
            existing.w9 = w9 ? {
              name: w9.name,
              address: w9.address,
              city: w9.city,
              state: w9.state,
              zip: w9.zip,
              taxClassification: w9.taxClassification,
              certificationDate: w9.certificationDate,
            } : undefined;
          } else if (contractsWithNames.length > 0 || w9) {
            // Add new entry for affiliates with contracts/W9 but no NDA
            resultMap.set(affiliate.id, {
              id: affiliate.id,
              name: affiliate.name,
              email: affiliate.email,
              contracts: contractsWithNames.length > 0 ? contractsWithNames : undefined,
              w9: w9 ? {
                name: w9.name,
                address: w9.address,
                city: w9.city,
                state: w9.state,
                zip: w9.zip,
                taxClassification: w9.taxClassification,
                certificationDate: w9.certificationDate,
              } : undefined,
            });
          }
        })
      );
      
      // Convert map to array and filter to only entries with at least one document
      const filesWithDocs = Array.from(resultMap.values()).filter(
        (a) => a.nda || (a.contracts && a.contracts.length > 0) || a.w9
      );
      
      console.log("[DEBUG] affiliate-files: Returning", filesWithDocs.length, "entries with documents");
      if (filesWithDocs.length > 0) {
        console.log("[DEBUG] First entry with docs:", JSON.stringify({ id: filesWithDocs[0].id, name: filesWithDocs[0].name, hasNda: !!filesWithDocs[0].nda, hasContracts: !!filesWithDocs[0].contracts }));
      }
      
      res.json(filesWithDocs);
    } catch (error) {
      console.error("Master portal files error:", error);
      res.status(500).json({ message: "Failed to fetch affiliate files" });
    }
  });

  // ===== AFFILIATE ROUTES =====

  // Get assigned affiliate applications
  app.get("/api/affiliate/applications", requireAffiliate, async (req, res) => {
    try {
      const applications = await storage.getAffiliateApplicationsByAssignee(req.session.userId!);
      res.json(applications);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch applications" });
    }
  });

  // Get assigned help requests
  app.get("/api/affiliate/help-requests", requireAffiliate, async (req, res) => {
    try {
      const requests = await storage.getHelpRequestsByAssignee(req.session.userId!);
      res.json(requests);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch requests" });
    }
  });

  // Update affiliate application status (affiliate)
  app.patch("/api/affiliate/applications/:id", requireAffiliate, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { status, notes } = req.body;
      
      // Verify this application is assigned to this affiliate
      const app = await storage.getAffiliateApplication(id);
      if (!app || app.assignedTo !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized to update this application" });
      }
      
      const updated = await storage.updateAffiliateApplication(id, { status, notes });
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update application" });
    }
  });

  // Update help request status (affiliate)
  app.patch("/api/affiliate/help-requests/:id", requireAffiliate, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { status, notes } = req.body;
      
      // Verify this request is assigned to this affiliate
      const request = await storage.getHelpRequest(id);
      if (!request || request.assignedTo !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized to update this request" });
      }
      
      const updated = await storage.updateHelpRequest(id, { status, notes });
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update request" });
    }
  });

  // Get affiliate's referral info
  app.get("/api/affiliate/referral-info", requireAffiliate, async (req, res) => {
    try {
      const user = await storage.getUser(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Generate referral code if not exists
      let referralCode = user.referralCode;
      if (!referralCode) {
        const crypto = await import('crypto');
        const namePrefix = user.name.substring(0, 4).toUpperCase().replace(/[^A-Z]/g, 'X');
        const randomSuffix = crypto.randomBytes(3).toString('hex').toUpperCase();
        referralCode = namePrefix + randomSuffix;
        await storage.updateUserReferralCode(user.id, referralCode);
      }
      
      // Count referrals
      const allHelpRequests = await storage.getAllHelpRequests();
      const referredLeads = allHelpRequests.filter(r => r.referredBy === user.id);
      
      res.json({
        referralCode,
        referralLink: `/get-help?ref=${referralCode}`,
        totalReferrals: referredLeads.length,
        activeReferrals: referredLeads.filter(r => r.status !== 'closed').length,
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to get referral info" });
    }
  });

  // Submit VSO Air Support Request (affiliate requests master to send projections to a VSO)
  app.post("/api/affiliate/vso-air-support", requireAffiliate, async (req, res) => {
    try {
      const { vsoName, vsoEmail, comments } = req.body;
      const user = await storage.getUser(req.session.userId!);
      
      if (!vsoName || !vsoEmail) {
        return res.status(400).json({ message: "VSO name and email are required" });
      }
      
      // Send email notification to master/admin about the air support request
      if (process.env.RESEND_API_KEY) {
        const resend = new Resend(process.env.RESEND_API_KEY);
        await resend.emails.send({
          from: "NavigatorUSA <no-reply@navigatorusa.com>",
          to: process.env.ADMIN_EMAIL || "admin@navigatorusa.com",
          subject: `VSO Air Support Request from ${user?.name}`,
          html: `
            <h2>VSO Air Support Request</h2>
            <p><strong>Requesting Affiliate:</strong> ${user?.name} (${user?.email})</p>
            <p><strong>VSO Name:</strong> ${vsoName}</p>
            <p><strong>VSO Email:</strong> ${vsoEmail}</p>
            <p><strong>Comments:</strong> ${comments || 'None'}</p>
            <hr/>
            <p>This affiliate is requesting you send VSO Revenue Projections to the above VSO contact.</p>
            <p>If this VSO signs up, the requesting affiliate earns a 1% recruiter bonus on all VSO revenue.</p>
          `,
        });
      }
      
      res.json({ success: true, message: "Air support request submitted. Master will review and send projections." });
    } catch (error) {
      console.error("VSO air support error:", error);
      res.status(500).json({ message: "Failed to submit air support request" });
    }
  });

  // Check if affiliate has signed NDA
  app.get("/api/affiliate/nda-status", requireAffiliate, async (req, res) => {
    try {
      const hasSigned = await storage.hasAffiliateSignedNda(req.session.userId!);
      const nda = hasSigned ? await storage.getAffiliateNdaByUserId(req.session.userId!) : null;
      res.json({ hasSigned, nda });
    } catch (error) {
      res.status(500).json({ message: "Failed to check NDA status" });
    }
  });

  // Get all NDAs for master portal
  app.get("/api/master/ndas", requireAdmin, async (req, res) => {
    try {
      const ndas = await storage.getAllAffiliateNdas();
      // Enrich with user details
      const enrichedNdas = await Promise.all(ndas.map(async (nda) => {
        const user = await storage.getUser(nda.userId);
        return {
          ...nda,
          affiliateName: user?.name || 'Unknown',
          affiliateEmail: user?.email || 'Unknown',
        };
      }));
      res.json(enrichedNdas);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch NDAs" });
    }
  });

  // Generate NDA PDF for download
  app.post("/api/master/affiliate-nda-pdf/:ndaId", requireAdmin, async (req, res) => {
    try {
      const ndaId = parseInt(req.params.ndaId);
      const { securityKey } = req.body;
      
      // Validate security key
      const expectedKey = process.env.ADMIN_SETUP_KEY;
      if (!expectedKey || securityKey !== expectedKey) {
        return res.status(403).json({ message: "Invalid security key" });
      }
      
      // Get NDA data
      const nda = await storage.getAffiliateNdaById(ndaId);
      if (!nda) {
        return res.status(404).json({ message: "NDA not found" });
      }
      
      // Import PDF generator dynamically
      const { generateNdaPdf } = await import('./pdfGenerator');
      
      const pdfBuffer = await generateNdaPdf({
        fullName: nda.fullName,
        veteranNumber: nda.veteranNumber || undefined,
        address: nda.address || undefined,
        signedAt: nda.signedAt?.toISOString() || new Date().toISOString(),
        signedIpAddress: nda.signedIpAddress || undefined,
        signatureData: nda.signatureData || undefined,
        facePhoto: nda.facePhoto || undefined,
        idPhoto: nda.idPhoto || undefined
      });
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="NDA-${nda.fullName.replace(/[^a-zA-Z0-9]/g, '_')}-${new Date().toISOString().split('T')[0]}.pdf"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error("PDF generation error:", error);
      res.status(500).json({ message: "Failed to generate PDF" });
    }
  });

  // Sign affiliate NDA
  app.post("/api/affiliate/sign-nda", requireAffiliate, async (req, res) => {
    try {
      const { fullName, veteranNumber, address, customReferralCode, signatureData, facePhoto, idPhoto, agreedToTerms } = req.body;
      
      // Validate required fields
      if (!fullName || typeof fullName !== 'string' || fullName.trim().length < 2) {
        return res.status(400).json({ message: "Full legal name is required (at least 2 characters)" });
      }
      
      if (!address || typeof address !== 'string' || address.trim().length < 5) {
        return res.status(400).json({ message: "Address is required (at least 5 characters)" });
      }
      
      if (!signatureData || typeof signatureData !== 'string' || !signatureData.startsWith('data:image/')) {
        return res.status(400).json({ message: "Your signature is required - please sign in the signature box" });
      }
      
      if (!facePhoto || typeof facePhoto !== 'string' || !facePhoto.startsWith('data:image/')) {
        return res.status(400).json({ message: "Face photo is required - please capture your face using webcam" });
      }
      
      if (!idPhoto || typeof idPhoto !== 'string' || !idPhoto.startsWith('data:image/')) {
        return res.status(400).json({ message: "ID document upload is required - must be an image file" });
      }
      
      if (agreedToTerms !== true && agreedToTerms !== 'true') {
        return res.status(400).json({ message: "You must agree to the terms to proceed" });
      }
      
      // Check if already signed
      const alreadySigned = await storage.hasAffiliateSignedNda(req.session.userId!);
      if (alreadySigned) {
        return res.status(400).json({ message: "NDA already signed" });
      }

      // Get IP address
      const ipAddress = req.headers['x-forwarded-for'] as string || req.socket.remoteAddress || 'unknown';
      
      // Create NDA record
      const nda = await storage.createAffiliateNda({
        userId: req.session.userId!,
        fullName,
        veteranNumber: veteranNumber || null,
        address,
        customReferralCode: customReferralCode || null,
        signatureData: signatureData || null,
        facePhoto: facePhoto || null,
        idPhoto: idPhoto || null,
        signedIpAddress: ipAddress,
        agreedToTerms: "true",
      });
      
      // Update user's referral code if custom one provided
      if (customReferralCode) {
        await storage.updateUserReferralCode(req.session.userId!, customReferralCode.toUpperCase());
      }
      
      res.json({ success: true, nda });
    } catch (error) {
      console.error("NDA signing error:", error);
      res.status(500).json({ message: "Failed to sign NDA" });
    }
  });

  // Get W9 status for affiliate
  app.get("/api/affiliate/w9-status", requireAffiliate, async (req, res) => {
    try {
      const hasSubmitted = await storage.hasAffiliateSubmittedW9(req.session.userId!);
      const w9 = hasSubmitted ? await storage.getAffiliateW9ByUserId(req.session.userId!) : null;
      res.json({ hasSubmitted, w9: w9 ? { ...w9, ssn: w9.ssn ? "****" : null } : null });
    } catch (error) {
      res.status(500).json({ message: "Failed to check W9 status" });
    }
  });

  // Submit W9 form
  app.post("/api/affiliate/submit-w9", requireAffiliate, async (req, res) => {
    try {
      // Zod validation schema for W9
      const w9Schema = z.object({
        name: z.string().min(1, "Name is required").max(100),
        businessName: z.string().max(100).optional().nullable(),
        taxClassification: z.enum(["individual", "c_corp", "s_corp", "partnership", "trust", "llc"]).default("individual"),
        address: z.string().min(1, "Address is required").max(200),
        city: z.string().min(1, "City is required").max(100),
        state: z.string().min(2, "State is required").max(2).transform(s => s.toUpperCase()),
        zip: z.string().min(5, "ZIP is required").max(10).regex(/^\d{5}(-\d{4})?$/, "Invalid ZIP format"),
        ssn: z.string().optional().nullable().transform(val => val ? val.replace(/\D/g, '') : null).refine(val => !val || /^\d{9}$/.test(val), "SSN must be 9 digits"),
        ein: z.string().optional().nullable().refine(val => !val || /^\d{2}-?\d{7}$/.test(val), "Invalid EIN format"),
        signatureData: z.string().optional().nullable(),
      }).refine(data => data.ssn || data.ein, { message: "Either SSN or EIN is required" });
      
      // Verify NDA is signed before W9 submission
      const nda = await storage.getAffiliateNdaByUserId(req.session.userId!);
      if (!nda) {
        return res.status(400).json({ message: "You must sign the NDA before submitting W9" });
      }

      const validatedData = w9Schema.safeParse(req.body);
      if (!validatedData.success) {
        return res.status(400).json({ message: validatedData.error.errors[0]?.message || "Invalid input" });
      }

      const { name, businessName, taxClassification, address, city, state, zip, ssn, ein, signatureData } = validatedData.data;
      
      // Check if already submitted
      const alreadySubmitted = await storage.hasAffiliateSubmittedW9(req.session.userId!);
      if (alreadySubmitted) {
        return res.status(400).json({ message: "W9 already submitted" });
      }

      // Get IP address
      const ipAddress = req.headers['x-forwarded-for'] as string || req.socket.remoteAddress || 'unknown';
      
      // Only store last 4 digits of SSN for security
      const ssnLast4 = ssn ? ssn.replace(/\D/g, '').slice(-4) : null;
      
      const w9 = await storage.createAffiliateW9({
        userId: req.session.userId!,
        name,
        businessName: businessName || null,
        taxClassification: taxClassification || "individual",
        address,
        city,
        state,
        zip,
        ssn: ssnLast4,
        ein: ein || null,
        signatureData: signatureData || null,
        signedIpAddress: ipAddress,
      });
      
      res.json({ success: true, w9 });
    } catch (error) {
      console.error("W9 submission error:", error);
      res.status(500).json({ message: "Failed to submit W9" });
    }
  });

  // ===== ECOSYSTEM / MASTER PORTAL ROUTES =====

  // Get all opportunities
  app.get("/api/opportunities", async (req, res) => {
    try {
      const opps = await storage.getAllOpportunities();
      res.json(opps);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch opportunities" });
    }
  });

  // Create opportunity (admin only)
  app.post("/api/opportunities", requireAdmin, async (req, res) => {
    try {
      const data = insertOpportunitySchema.parse(req.body);
      const opp = await storage.createOpportunity(data);
      res.status(201).json(opp);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create opportunity" });
    }
  });

  // Update opportunity (admin only)
  app.patch("/api/opportunities/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateOpportunity(id, req.body);
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update opportunity" });
    }
  });

  // Get all sales (master portal)
  app.get("/api/master/sales", requireAdmin, async (req, res) => {
    try {
      const allSales = await storage.getAllSales();
      res.json(allSales);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch sales" });
    }
  });

  // Get all affiliates with stats (master portal)
  app.get("/api/master/affiliates", requireAdmin, async (req, res) => {
    try {
      const affiliates = await storage.getAllVltAffiliates();
      res.json(affiliates);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch affiliates" });
    }
  });

  // Get affiliates by role
  app.get("/api/master/affiliates/:role", requireAdmin, async (req, res) => {
    try {
      const affiliates = await storage.getVltAffiliatesByRole(req.params.role);
      res.json(affiliates);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch affiliates" });
    }
  });

  // Get downline for an affiliate
  app.get("/api/master/downline/:affiliateId", requireAdmin, async (req, res) => {
    try {
      const affiliateId = parseInt(req.params.affiliateId);
      const downline = await storage.getVltAffiliateDownline(affiliateId);
      res.json(downline);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch downline" });
    }
  });

  // Get all commissions (master portal)
  app.get("/api/master/commissions", requireAdmin, async (req, res) => {
    try {
      const affiliates = await storage.getAllVltAffiliates();
      const commissionsData = [];
      for (const aff of affiliates) {
        const comms = await storage.getCommissionsByAffiliate(aff.id);
        commissionsData.push({ affiliate: aff, commissions: comms });
      }
      res.json(commissionsData);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch commissions" });
    }
  });

  // Create sale with commission calculation
  app.post("/api/sales", async (req, res) => {
    try {
      const data = insertSaleSchema.parse(req.body);
      const sale = await storage.createSale(data);
      res.status(201).json(sale);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create sale" });
    }
  });

  // Update sale status
  app.patch("/api/sales/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateSale(id, req.body);
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update sale" });
    }
  });

  // Veteran Intake - multiple programs
  app.post("/api/veteran-intake", async (req, res) => {
    try {
      const data = insertVeteranIntakeSchema.parse(req.body);
      
      // If referral code provided, look up affiliate chain
      if (data.referralCode) {
        const affiliate = await storage.getVltAffiliateByReferralCode(data.referralCode);
        if (affiliate) {
          (data as any).referredByL1 = affiliate.id;
          (data as any).referredByL2 = affiliate.level1Id;
          (data as any).referredByL3 = affiliate.level2Id;
          (data as any).referredByL4 = affiliate.level3Id;
          (data as any).referredByL5 = affiliate.level4Id;
          (data as any).referredByL6 = affiliate.level5Id;
          (data as any).referredByL7 = affiliate.level6Id;
        }
      }
      
      const intake = await storage.createVeteranIntake(data);
      res.status(201).json({ success: true, id: intake.id });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to submit intake" });
    }
  });

  // Get all veteran intakes (admin)
  app.get("/api/admin/veteran-intakes", requireAdmin, async (req, res) => {
    try {
      const intakes = await storage.getAllVeteranIntakes();
      res.json(intakes);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch intakes" });
    }
  });

  // Update veteran intake
  app.patch("/api/admin/veteran-intakes/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateVeteranIntake(id, req.body);
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update intake" });
    }
  });

  // Business Intake - B2B services
  app.post("/api/business-intake", async (req, res) => {
    try {
      const data = insertBusinessIntakeSchema.parse(req.body);
      
      // If referral code provided, look up affiliate chain
      if (data.referralCode) {
        const affiliate = await storage.getVltAffiliateByReferralCode(data.referralCode);
        if (affiliate) {
          (data as any).referredByL1 = affiliate.id;
          (data as any).referredByL2 = affiliate.level1Id;
          (data as any).referredByL3 = affiliate.level2Id;
          (data as any).referredByL4 = affiliate.level3Id;
          (data as any).referredByL5 = affiliate.level4Id;
          (data as any).referredByL6 = affiliate.level5Id;
          (data as any).referredByL7 = affiliate.level6Id;
        }
      }
      
      const intake = await storage.createBusinessIntake(data);
      res.status(201).json({ success: true, id: intake.id });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to submit intake" });
    }
  });

  // Get all business intakes (admin)
  app.get("/api/admin/business-intakes", requireAdmin, async (req, res) => {
    try {
      const intakes = await storage.getAllBusinessIntakes();
      res.json(intakes);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch intakes" });
    }
  });

  // Update business intake
  app.patch("/api/admin/business-intakes/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateBusinessIntake(id, req.body);
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update intake" });
    }
  });

  // Promote affiliate to sub-master
  app.patch("/api/master/promote/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { role } = req.body; // 'sub_master' or 'master'
      const updated = await storage.updateVltAffiliate(id, { role });
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to promote affiliate" });
    }
  });

  // Sub-master portal - get own downline
  app.get("/api/submaster/downline", async (req, res) => {
    try {
      // For now, accept affiliate ID from query param (will use session in production)
      const affiliateId = parseInt(req.query.affiliateId as string);
      if (!affiliateId) {
        return res.status(400).json({ message: "Affiliate ID required" });
      }
      const downline = await storage.getVltAffiliateDownline(affiliateId);
      res.json(downline);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch downline" });
    }
  });

  // Sub-master - get sales from downline
  app.get("/api/submaster/sales", async (req, res) => {
    try {
      const affiliateId = parseInt(req.query.affiliateId as string);
      if (!affiliateId) {
        return res.status(400).json({ message: "Affiliate ID required" });
      }
      const sales = await storage.getSalesByDownline(affiliateId);
      res.json(sales);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch sales" });
    }
  });

  // ===== CONTRACT MANAGEMENT ROUTES =====

  // Seed MAH contract template (one-time setup)
  app.post("/api/contracts/seed-mah", async (req, res) => {
    try {
      const existingTemplates = await storage.getAllContractTemplates();
      if (existingTemplates.length > 0) {
        return res.json({ message: "Templates already exist", count: existingTemplates.length });
      }
      
      const mahContract = await storage.createContractTemplate({
        name: "Independent Representative Non-Disclosure, Non-Circumvention and Referral Agreement",
        version: "1.0",
        companyName: "MISSION ACT HEALTH, INC.",
        requiredFor: "all",
        isActive: "true",
        content: `<h1>INDEPENDENT REPRESENTATIVE NON-DISCLOSURE, NON-CIRCUMVENTION AND REFERRAL AGREEMENT</h1>

<p>THIS AGREEMENT is made by <strong>MISSION ACT HEALTH, INC.</strong>, a Virginia corporation taxed as a C-Corporation ("MAH") located at [Company Address], and the undersigned Independent Contractor ("Representative"), collectively referred to as the "Parties".</p>

<h2>RECITALS</h2>

<p>WHEREAS MAH engages in business development, marketing, and sales services generally, provides clients with advice and expertise relating to healthcare navigation, veteran services, disability assistance, holistic health education, financial planning, and a wide range of strategic, management, marketing, and financial services (MAH services); and,</p>

<p>WHEREAS, Representative wishes to offer to MAH, and MAH desires to receive from Representative, referrals of potential customers who may be interested in MAH's services, pursuant to the terms and conditions of this Agreement.</p>

<h2>NOW THEREFORE</h2>
<p>In consideration of the mutual covenants and promises contained in this Agreement as set forth below, MAH and Representative agree as follows:</p>

<h3>Section 1. Description of Work</h3>
<p>The services provided by the Representative to MAH shall be provided on an as-needed basis. MAH shall have sole discretion to establish the minimum qualifications necessary for the performance of any service rendered by the Representative under this Agreement.</p>

<h3>Section 2. Compensation</h3>
<p>MAH agrees to pay the Representative for services provided under this Agreement as outlined in Addendum A below.</p>

<h3>Section 3. Relationships of the Parties</h3>
<p>The Representative shall be considered an independent Contractor and is not an employee, partner, or joint venturer of MAH. Consistent with the foregoing, MAH shall not deduct withholding taxes, social security taxes, or any other taxes or fees required to be deducted by an employer from Representative's compensation.</p>

<h3>Section 4. Term of Engagement</h3>
<p>This Agreement will become effective upon electronic signature and will continue until Terminated under Section 16 below.</p>

<h3>Section 5. Responsibilities of the Representative</h3>
<p>The Representative shall have complete control over the time spent, the manner, and the disposition of the services provided. The Representative agrees to devote sufficient time and energy to fulfill the spirit and purpose of this Agreement.</p>

<h3>Section 6. Responsibilities of MAH</h3>
<p>MAH agrees to follow all reasonable requests of the Representative necessary to the performance of the Representative's duties under this Agreement. MAH agrees to provide the Representative with such information, marketing materials, customer relationship management (CRM) software, and other software as may be necessary to facilitate the efficient flow of business between the Parties.</p>

<h3>Section 7. Representations and Warranties</h3>
<p>Representative expressly represents and warrants that he/she is over the age of 18 and has the authority to enter into this Agreement.</p>

<h3>Section 8-11. [Standard Provisions]</h3>
<p>Waiver, Compliance, Representative's Employees, and Liability provisions apply as standard.</p>

<h3>Section 12. Confidentiality</h3>
<p>The Representative agrees that all proprietary knowledge and information shall be regarded as strictly confidential and held in confidence solely for MAH's benefit and use.</p>

<h3>Section 13. Non-Competition</h3>
<p>Representative agrees not to contact or initiate contact at any time for any purpose, either directly or indirectly, with any MAH referral without prior written consent.</p>

<h3>Section 14. Non-Solicitation and Non-Circumvention</h3>
<p>Neither Party will solicit or hire any Employee, Consultant, Customer, Referral, Client, Strategic Partner, or Service Provider of the other Party for a period of one year following termination.</p>

<h3>Section 15. Indemnity</h3>
<p>The Representative shall indemnify and hold MAH free and harmless from any obligations, debts, suits, costs, claims, judgments, liabilities, attorneys' fees, liens, and attachments.</p>

<h3>Section 16. Termination of Agreement</h3>
<p>Either Party may terminate this Agreement at any time, with or without cause, provided the Terminating Party provides 30-day prior written notice. All commissions owed shall survive the termination of this Agreement.</p>

<h3>Section 17-28. [Standard Legal Provisions]</h3>
<p>Partial Invalidity, Entire Agreement, Assignment, Counterparts, Acknowledgment, Notices, Governing Law (Commonwealth of Virginia), Attorney's Fees, Arbitration, Force Majeure, Amendment, and Headings provisions apply as standard.</p>

<hr/>

<h2>ADDENDUM A - TIERED SALES STRUCTURE COMPENSATION</h2>

<p>With respect to the Products/Services, the following Commission Structures will apply:</p>

<table border="1" cellpadding="8" style="width:100%; border-collapse: collapse;">
  <tr style="background-color: #f0f0f0;"><th>Role</th><th>Commission Rate</th></tr>
  <tr><td><strong>Primary Referral Agent (Top Rep)</strong></td><td>75% of Net Vendor/Client Claim Fee (NVCCF)</td></tr>
  <tr><td>Level One Referral Partner</td><td>10% of NVCCF</td></tr>
  <tr><td>Level Two Referral Partner</td><td>10% of NVCCF</td></tr>
  <tr><td>Level Three Referral Partner</td><td>5% of NVCCF</td></tr>
</table>

<p><em>Note: Tiers are static and not compressed. Breakage rolls up to the Company (MAH).</em></p>

<h3>Commission Payment Process</h3>
<ul>
  <li>Active Representatives will be paid by the 15th of the month for funds received by MAH in the preceding month for Net Sales of Paid Invoices on Accounts generated by the Representative.</li>
  <li>Representative will provide ACH account information to be paid electronically by MAH.</li>
</ul>

<h3>Definitions</h3>
<ul>
  <li><strong>Commission Entitlement:</strong> The Active Representative shall be entitled to receive a "Commission" on "Net Sales" of fully "Paid Invoices" from "Active Accounts".</li>
  <li><strong>Client:</strong> Any business account, individual, group, organization, or entity to whom the Products or Services are marketed, solicited, sold, or purchased.</li>
  <li><strong>Net Sales of Paid Invoices:</strong> Amounts specified by MAH's generated invoices issued in any month, less taxes, refunds, credits, returns, rebates, discounts, shipping costs, adjustments, and bad debts.</li>
</ul>

<p style="margin-top: 30px;"><strong>By signing below, you acknowledge that you have read, understand, and agree to be bound by this Agreement.</strong></p>`
      });
      
      res.status(201).json({ success: true, template: mahContract });
    } catch (error) {
      console.error("Error seeding MAH contract:", error);
      res.status(500).json({ message: "Failed to seed contract template" });
    }
  });

  // Seed all MAH service contracts
  app.post("/api/contracts/seed-all-services", async (req, res) => {
    try {
      const existing = await storage.getAllContractTemplates();
      const results: any[] = [];

      // Define all MAH services from the BSBA contract structure
      const services = [
        { name: "Private Reinsurance eR3", grossPct: 70, description: "Private Reinsurance Program - eR3" },
        { name: "Private Reinsurance eR2", grossPct: 70, description: "Private Reinsurance Program - eR2" },
        { name: "Tax Resolution Services", grossPct: 55, description: "Legacy Tax & Resolution Services - Tier One" },
        { name: "FICA Tips Tax Credit", grossPct: 70, description: "FICA Tips Tax Credit Recovery" },
        { name: "Tax Recovery", grossPct: 70, description: "Tax Recovery Services" },
        { name: "ICC Logistics", grossPct: 18, description: "ICC Logistics Revenue Sharing" },
      ];

      for (const svc of services) {
        const exists = existing.find(t => t.serviceName === svc.name);
        if (exists) {
          results.push({ service: svc.name, status: "exists", id: exists.id });
          continue;
        }

        const contract = await storage.createContractTemplate({
          name: `${svc.name} Revenue Sharing Agreement`,
          version: "1.0",
          companyName: "MISSION ACT HEALTH, INC.",
          requiredFor: "affiliate",
          isActive: "true",
          contractType: "service",
          grossCommissionPct: svc.grossPct,
          serviceName: svc.name,
          content: `<h1>${svc.name.toUpperCase()} REVENUE SHARING AGREEMENT</h1>

<p>This Revenue Sharing Agreement ("Agreement") is between <strong>MISSION ACT HEALTH, INC.</strong>, a Virginia corporation ("MAH"), and the undersigned Independent Representative ("Representative").</p>

<h2>SERVICE DESCRIPTION</h2>
<p>${svc.description}</p>

<h2>COMPENSATION</h2>
<p>Compensation payable to the Representative network shall be governed by Schedule A.</p>

<p><strong>Gross Commission Rate: ${svc.grossPct}%</strong></p>

<p>The ${svc.grossPct}% gross commission shall be distributed according to the Schedule A compensation structure based on the Representative's position within the MAH network:</p>

<table border="1" cellpadding="8" style="width:100%; border-collapse: collapse;">
  <tr style="background-color: #f0f0f0;"><th>Recipient</th><th>Rate</th></tr>
  <tr><td><strong>Producer (You)</strong></td><td>69% base + compression from empty uplines</td></tr>
  <tr><td>Each Upline (max 6)</td><td>1% each</td></tr>
  <tr><td>House (MAH)</td><td>22.5%</td></tr>
  <tr><td>Recruiter Bounty</td><td>2.5%</td></tr>
</table>

<p><strong>Compression:</strong> Empty upline levels compress TO THE PRODUCER. A solo producer with no uplines receives 75% (69% + 6%).</p>

<h2>TERM AND TERMINATION</h2>
<p>This Agreement will commence upon its execution and continue until terminated by either party with 30 days prior written notice.</p>

<h2>RELATIONSHIP OF PARTIES</h2>
<p>The Representative is an independent contractor, not an employee, partner, or joint venturer of MAH.</p>

<h2>GOVERNING LAW</h2>
<p>This Agreement will be governed by the laws of the Commonwealth of Virginia.</p>

<hr/>

<p><strong>By signing below, you acknowledge that you have read, understand, and agree to be bound by this Agreement and the attached Schedule A.</strong></p>`
        });

        results.push({ service: svc.name, status: "created", id: contract.id });
      }

      res.status(201).json({ success: true, results });
    } catch (error) {
      console.error("Error seeding service contracts:", error);
      res.status(500).json({ message: "Failed to seed service contracts" });
    }
  });

  // Seed ICC Logistics service contract (legacy endpoint)
  app.post("/api/contracts/seed-icc", async (req, res) => {
    try {
      const existing = await storage.getAllContractTemplates();
      const iccExists = existing.find(t => t.serviceName === "ICC Logistics");
      if (iccExists) {
        return res.json({ message: "ICC Logistics contract already exists", id: iccExists.id });
      }

      const iccContract = await storage.createContractTemplate({
        name: "ICC Logistics Revenue Sharing Agreement",
        version: "1.0",
        companyName: "MISSION ACT HEALTH, INC.",
        requiredFor: "affiliate",
        isActive: "true",
        contractType: "service",
        grossCommissionPct: 18,
        serviceName: "ICC Logistics",
        content: `<h1>REVENUE SHARING AGREEMENT</h1>

<p>This Revenue Sharing Agreement ("Agreement") is between <strong>MISSION ACT HEALTH, Inc.</strong>, a Virginia corporation ("MAH"), on behalf of services rendered by <strong>ICC LOGISTICS, INC</strong> ("ICC"), a New York corporation, and the undersigned Referral Agent.</p>

<h2>RECITALS</h2>
<p>MISSION ACT HEALTH, LLC is the Master Agent and will have the responsibility of paying all commissions due to the Referral Agent five (5) days from receipt of funds from ICC.</p>

<h2>OBJECTIVES</h2>
<p>ICC and Referral Agent both have expertise in business consulting services and wish to enter into an arrangement whereby Referral Agent will introduce to ICC certain customers and prospects in return for a share of the revenues generated from business arising as a result of those introductions.</p>

<h2>RELATIONSHIP OF PARTIES</h2>
<p>In the performance of this Agreement, the parties will at all times remain independent legal entities and operate as independent contractors, and not the other party's partner or joint venturer.</p>

<h2>CONFIDENTIALITY</h2>
<p>The identity of any prospects or customers introduced by one party to the other shall remain confidential and shall not be disclosed to any other person or entity.</p>

<h2>TERM AND TERMINATION</h2>
<p>This Agreement will commence upon its execution and continue until the expiration of all projects governed under this Agreement. Either party may terminate this Agreement at any time upon 30 days prior written notice.</p>

<h2>COMPENSATION</h2>
<p>Compensation payable to the Referral Agent network shall be governed by Schedule A.</p>

<p><strong>Base Commission Rate:</strong></p>
<ul>
  <li><strong>All Other Services (excluding Audit):</strong> 18% of ICC's gross revenue</li>
  <li><strong>Audit Services:</strong> 5% of ICC's net revenue</li>
</ul>

<p>The 18% gross commission shall be distributed according to the Schedule A compensation structure based on the Referral Agent's position within the MAH network:</p>

<table border="1" cellpadding="8" style="width:100%; border-collapse: collapse;">
  <tr style="background-color: #f0f0f0;"><th>Recipient</th><th>Rate</th></tr>
  <tr><td><strong>Producer (You)</strong></td><td>69% base + compression from empty uplines</td></tr>
  <tr><td>Each Upline (max 6)</td><td>1% each</td></tr>
  <tr><td>House</td><td>22.5%</td></tr>
  <tr><td>Recruiter Bounty</td><td>2.5%</td></tr>
</table>

<p><strong>Compression:</strong> Empty upline levels compress to the Producer. A solo producer with no uplines receives 75% (69% + 6%).</p>

<h2>APPLICABLE LAW</h2>
<p>This Agreement will be interpreted in accordance with the laws of the State of New York.</p>

<h2>ARBITRATION</h2>
<p>Any disputes arising out of this Agreement will be settled by binding arbitration in accordance with the Commercial Arbitration Rules of the American Arbitration Association.</p>

<hr/>

<p><strong>By signing below, you acknowledge that you have read, understand, and agree to be bound by this Agreement and the attached Schedule A.</strong></p>`
      });

      res.status(201).json({ success: true, template: iccContract });
    } catch (error) {
      console.error("Error seeding ICC contract:", error);
      res.status(500).json({ message: "Failed to seed ICC contract template" });
    }
  });

  // Get all contract templates
  app.get("/api/contracts/templates", async (req, res) => {
    try {
      const templates = await storage.getAllContractTemplates();
      res.json(templates);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch templates" });
    }
  });

  // Get active contract templates
  app.get("/api/contracts/templates/active", async (req, res) => {
    try {
      const templates = await storage.getActiveContractTemplates();
      res.json(templates);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch templates" });
    }
  });

  // Get a single contract template
  app.get("/api/contracts/templates/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const template = await storage.getContractTemplate(id);
      if (!template) {
        return res.status(404).json({ message: "Template not found" });
      }
      res.json(template);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch template" });
    }
  });

  // Create contract template (admin only)
  app.post("/api/contracts/templates", requireAdmin, async (req, res) => {
    try {
      const data = insertContractTemplateSchema.parse(req.body);
      const template = await storage.createContractTemplate(data);
      res.status(201).json(template);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create template" });
    }
  });

  // Update contract template (admin only)
  app.patch("/api/contracts/templates/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateContractTemplate(id, req.body);
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update template" });
    }
  });

  // Get all signed agreements (admin/master)
  app.get("/api/contracts/signed", requireAdmin, async (req, res) => {
    try {
      const agreements = await storage.getAllSignedAgreements();
      res.json(agreements);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch agreements" });
    }
  });

  // Get signed agreements for a specific affiliate
  app.get("/api/contracts/signed/affiliate/:affiliateId", requireAuth, async (req, res) => {
    try {
      const affiliateId = parseInt(req.params.affiliateId);
      const agreements = await storage.getSignedAgreementsByAffiliate(affiliateId);
      res.json(agreements);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch agreements" });
    }
  });

  // Check if affiliate has signed a specific contract
  app.get("/api/contracts/check/:affiliateId/:templateId", requireAuth, async (req, res) => {
    try {
      const affiliateId = parseInt(req.params.affiliateId);
      const templateId = parseInt(req.params.templateId);
      const hasSigned = await storage.hasAffiliateSignedContract(affiliateId, templateId);
      res.json({ hasSigned });
    } catch (error) {
      res.status(500).json({ message: "Failed to check signature" });
    }
  });

  // Sign a contract
  app.post("/api/contracts/sign", requireAuth, async (req, res) => {
    try {
      const data = insertSignedAgreementSchema.parse(req.body);
      const clientIp = req.headers['x-forwarded-for'] || req.socket.remoteAddress;
      const signedAgreement = await storage.createSignedAgreement({
        ...data,
        signedIpAddress: Array.isArray(clientIp) ? clientIp[0] : clientIp || 'unknown'
      });
      res.status(201).json({ success: true, id: signedAgreement.id });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      console.error("Contract signing error:", error);
      res.status(500).json({ message: "Failed to sign contract" });
    }
  });

  // Get pending contracts for an affiliate (contracts they haven't signed yet)
  app.get("/api/contracts/pending/:affiliateId", requireAuth, async (req, res) => {
    try {
      const affiliateId = parseInt(req.params.affiliateId);
      const allTemplates = await storage.getActiveContractTemplates();
      const signedAgreements = await storage.getSignedAgreementsByAffiliate(affiliateId);
      const signedTemplateIds = signedAgreements.map(sa => sa.contractTemplateId);
      const pendingTemplates = allTemplates.filter(t => !signedTemplateIds.includes(t.id));
      res.json(pendingTemplates);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch pending contracts" });
    }
  });

  // Get signed agreements for the current logged-in user
  app.get("/api/contracts/my-signed", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.json([]);
      }
      const signedAgreements = await storage.getSignedAgreementsByAffiliate(req.session.userId);
      res.json(signedAgreements);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch signed agreements" });
    }
  });

  // ===== COMMISSION CALCULATION API =====

  // Calculate commission breakdown for a sale
  app.post("/api/commission/calculate", async (req, res) => {
    try {
      const { grossRevenue, recruiterExists = true, l2Active = true, l3Active = true, l4Active = true, l5Active = true } = req.body;
      
      const gross = Math.max(0, Number(grossRevenue) || 0);
      
      const pct = {
        recruiter: 0.025,
        l1: 0.67,
        l2: 0.035,
        l3: 0.020,
        l4: 0.012,
        l5: 0.008,
        l6: 0.005,
      };

      const recruiterPay = recruiterExists ? Math.round(gross * pct.recruiter * 100) : 0;
      const l1Pay = Math.round(gross * pct.l1 * 100);
      
      const l2Base = Math.round(gross * pct.l2 * 100);
      const l3Base = Math.round(gross * pct.l3 * 100);
      const l4Base = Math.round(gross * pct.l4 * 100);
      const l5Base = Math.round(gross * pct.l5 * 100);
      const l6Base = Math.round(gross * pct.l6 * 100);

      const l2Pay = l2Active ? l2Base : 0;
      const l3Pay = l3Active ? l3Base : 0;
      const l4Pay = l4Active ? l4Base : 0;
      const l5Pay = l5Active ? l5Base : 0;

      const compressedToL6 =
        (l2Active ? 0 : l2Base) +
        (l3Active ? 0 : l3Base) +
        (l4Active ? 0 : l4Base) +
        (l5Active ? 0 : l5Base);

      const l6Pay = l6Base + compressedToL6;

      res.json({
        grossRevenue: gross,
        grossRevenueCents: Math.round(gross * 100),
        recruiterBounty: recruiterPay,
        l1Commission: l1Pay,
        l2Commission: l2Pay,
        l3Commission: l3Pay,
        l4Commission: l4Pay,
        l5Commission: l5Pay,
        l6Commission: l6Pay,
        compressedToL6: compressedToL6,
        totalPaid: recruiterPay + l1Pay + l2Pay + l3Pay + l4Pay + l5Pay + l6Pay,
        houseAllocation: l1Pay + l2Pay + l3Pay + l4Pay + l5Pay + l6Pay,
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to calculate commissions" });
    }
  });

  // Get commission configuration (simplified model)
  app.get("/api/commission/config", async (req, res) => {
    try {
      const config = await storage.getActiveCommissionConfig();
      if (!config) {
        // Return simplified defaults
        res.json({
          producerBasePct: 69,
          uplinePctEach: 1,
          maxUplineLevels: 6,
          housePct: 22.5,
          recruiterBountyPct: 2.5,
        });
      } else {
        res.json({
          producerBasePct: config.producerBasePct,
          uplinePctEach: config.uplinePctEach,
          maxUplineLevels: config.maxUplineLevels,
          housePct: config.housePct,
          recruiterBountyPct: config.recruiterBountyPct,
        });
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to get commission config" });
    }
  });

  // Seed default commission config (simplified model)
  app.post("/api/commission/seed", requireAdmin, async (req, res) => {
    try {
      const existing = await storage.getActiveCommissionConfig();
      if (existing) {
        return res.json({ success: true, message: "Config already exists", config: existing });
      }
      const config = await storage.createCommissionConfig({
        name: "default",
        producerBasePct: 69,
        uplinePctEach: 1,
        maxUplineLevels: 6,
        housePct: 22.5,
        recruiterBountyPct: 2.5,
        isActive: "true",
      });
      res.json({ success: true, config });
    } catch (error) {
      res.status(500).json({ message: "Failed to seed commission config" });
    }
  });

  // === Business Leads API ===
  
  // Public: Submit a business lead
  app.post("/api/business-leads", async (req, res) => {
    try {
      const { referralCode, ...rest } = req.body;
      const data = insertBusinessLeadSchema.parse(rest);
      
      // Get client IP address
      const clientIp = req.headers['x-forwarded-for']?.toString().split(',')[0] || req.socket.remoteAddress || 'unknown';
      
      // Look up affiliate by referral code if provided, or check IP tracking
      let referredById: number | undefined;
      let finalReferralCode = referralCode;
      
      if (referralCode) {
        // Referral code provided - use it and track IP
        const affiliate = await storage.getUserByReferralCode(referralCode);
        if (affiliate) {
          referredById = affiliate.id;
          // Track this IP if not already tracked
          const existingIpTracking = await storage.getActiveIpReferral(clientIp);
          if (!existingIpTracking) {
            const expiresAt = new Date();
            expiresAt.setDate(expiresAt.getDate() + 30); // 30 day expiration
            await storage.createIpReferralTracking({
              ipAddress: clientIp,
              affiliateId: affiliate.id,
              referralCode: referralCode,
              expiresAt,
            });
          }
        }
      } else {
        // No referral code - check if IP is already tracked
        const ipTracking = await storage.getActiveIpReferral(clientIp);
        if (ipTracking && ipTracking.affiliateId) {
          referredById = ipTracking.affiliateId;
          finalReferralCode = ipTracking.referralCode;
        }
      }
      
      const lead = await storage.createBusinessLead({
        ...data,
        referralCode: finalReferralCode || undefined,
        referredBy: referredById,
      } as any);
      res.status(201).json({ success: true, lead });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      console.error("Error creating business lead:", error);
      res.status(500).json({ message: "Failed to submit business lead" });
    }
  });

  // Admin/Master: Get all business leads
  app.get("/api/admin/business-leads", requireAdmin, async (req, res) => {
    try {
      const leads = await storage.getAllBusinessLeads();
      res.json(leads);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch business leads" });
    }
  });

  // Master portal: Get all business leads (for master users)
  app.get("/api/master/business-leads", async (req, res) => {
    try {
      const leads = await storage.getAllBusinessLeads();
      res.json(leads);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch business leads" });
    }
  });

  // Affiliate: Get business leads referred by this affiliate
  app.get("/api/affiliate/business-leads", requireAffiliate, async (req, res) => {
    try {
      const leads = await storage.getBusinessLeadsByReferrer(req.session.userId!);
      res.json(leads);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch business leads" });
    }
  });

  // Admin: Update business lead
  app.patch("/api/admin/business-leads/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updated = await storage.updateBusinessLead(id, req.body);
      if (!updated) {
        return res.status(404).json({ message: "Lead not found" });
      }
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update business lead" });
    }
  });

  // === Security Tracking API ===

  // Master portal: Get all IP referral tracking with enriched data
  app.get("/api/master/security-tracking", requireAdmin, async (req, res) => {
    try {
      const ipReferrals = await storage.getAllIpReferrals();
      const allAffiliates = await storage.getAllAffiliates();
      const allNdas = await storage.getAllAffiliateNdas();
      const allHelpRequests = await storage.getAllHelpRequests();
      const allBusinessLeads = await storage.getAllBusinessLeads();
      
      // Enrich each IP tracking record with affiliate info, NDA status, and conversion status
      const enrichedData = await Promise.all(ipReferrals.map(async (tracking: any) => {
        const affiliate = allAffiliates.find((a: any) => a.id === tracking.affiliateId);
        const now = new Date();
        const isActive = tracking.expiresAt > now;
        
        // Check if this IP has any submissions (help requests or business leads)
        // This shows if they "became a lead"
        const hasHelpRequest = allHelpRequests.some(hr => hr.referredBy === tracking.affiliateId);
        const hasBusinessLead = allBusinessLeads.some(bl => bl.referredBy === tracking.affiliateId);
        
        return {
          id: tracking.id,
          ipAddress: tracking.ipAddress,
          referralCode: tracking.referralCode,
          affiliateId: tracking.affiliateId,
          affiliateName: affiliate?.name || 'Unknown',
          affiliateEmail: affiliate?.email || 'Unknown',
          expiresAt: tracking.expiresAt,
          createdAt: tracking.createdAt,
          isActive,
          clicked: true, // If we have a record, they clicked
          hasConvertedToLead: hasHelpRequest || hasBusinessLead,
        };
      }));
      
      // Also get affiliate list with their NDA status
      const affiliatesWithNdaStatus = allAffiliates
        .filter((a: any) => a.role === 'affiliate' || a.role === 'submaster')
        .map((affiliate: any) => {
          const hasSignedNda = allNdas.some(nda => nda.userId === affiliate.id);
          const referralCount = ipReferrals.filter(r => r.affiliateId === affiliate.id).length;
          return {
            id: affiliate.id,
            name: affiliate.name,
            email: affiliate.email,
            role: affiliate.role,
            referralCode: affiliate.referralCode,
            hasSignedNda,
            referralCount,
            createdAt: affiliate.createdAt,
          };
        });
      
      res.json({
        ipTracking: enrichedData,
        affiliates: affiliatesWithNdaStatus,
        totalTrackedIPs: ipReferrals.length,
        activeTracking: enrichedData.filter(d => d.isActive).length,
      });
    } catch (error) {
      console.error("Error fetching security tracking:", error);
      res.status(500).json({ message: "Failed to fetch security tracking data" });
    }
  });

  // Affiliate: Get their own IP referral tracking
  app.get("/api/affiliate/security-tracking", requireAffiliate, async (req, res) => {
    try {
      const ipReferrals = await storage.getIpReferralsByAffiliate(req.session.userId!);
      const now = new Date();
      const allHelpRequests = await storage.getHelpRequestsByAssignee(req.session.userId!);
      const allBusinessLeads = await storage.getBusinessLeadsByReferrer(req.session.userId!);
      
      // Check if user has signed NDA
      const hasSignedNda = await storage.hasAffiliateSignedNda(req.session.userId!);
      
      const enrichedData = ipReferrals.map(tracking => {
        const isActive = tracking.expiresAt > now;
        return {
          id: tracking.id,
          ipAddress: tracking.ipAddress,
          referralCode: tracking.referralCode,
          expiresAt: tracking.expiresAt,
          createdAt: tracking.createdAt,
          isActive,
          clicked: true,
        };
      });
      
      res.json({
        ipTracking: enrichedData,
        totalTrackedIPs: ipReferrals.length,
        activeTracking: enrichedData.filter(d => d.isActive).length,
        totalLeadsConverted: allHelpRequests.length + allBusinessLeads.length,
        hasSignedNda,
      });
    } catch (error) {
      console.error("Error fetching affiliate security tracking:", error);
      res.status(500).json({ message: "Failed to fetch security tracking data" });
    }
  });

  // =====================================================
  // STRESS TEST SIMULATION API
  // =====================================================
  
  // Run stress test simulation with 1000 sales across 30 affiliates
  // Public endpoint for demo purposes
  app.post("/api/stress-test/run", async (req, res) => {
    try {
      // Get configurable parameters from request body
      const { 
        numSales = 1000, 
        numAffiliates = 30, 
        hierarchyRandomness = 50 
      } = req.body;
      
      // Validate and clamp values
      const salesCount = Math.min(Math.max(1, numSales), 5000);
      const affiliateCount = Math.min(Math.max(5, numAffiliates), 100);
      const randomness = Math.min(Math.max(0, hierarchyRandomness), 100) / 100;
      
      const militaryRanks = ["E1", "E2", "E3", "E4", "E5", "E6", "E7"];
      const firstNames = ["James", "Michael", "Robert", "John", "David", "William", "Richard", "Joseph", "Thomas", "Charles", "Christopher", "Daniel", "Matthew", "Anthony", "Mark", "Donald", "Steven", "Andrew", "Paul", "Joshua", "Kenneth", "Kevin", "Brian", "George", "Timothy"];
      const lastNames = ["Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller", "Davis", "Rodriguez", "Martinez", "Hernandez", "Lopez", "Gonzalez", "Wilson", "Anderson", "Thomas", "Taylor", "Moore", "Jackson", "Martin", "Lee", "Perez", "Thompson", "White", "Harris"];
      const roles = ["master", "sub_master", "affiliate", "affiliate", "affiliate", "affiliate", "affiliate"];
      const categories = ["disability", "holistic", "healthcare", "insurance", "tax_credits", "b2b", "b2c"];
      const statuses = ["pending", "approved", "paid"];
      
      // Step 1: Create test opportunities if none exist
      let existingOpportunities = await storage.getAllOpportunities();
      if (existingOpportunities.length === 0) {
        const testOpportunities = [
          { name: "VA Disability Claim", category: "disability", description: "VA Disability assistance", commissionType: "percentage", commissionL1: 6900, commissionL2: 100, commissionL3: 100, commissionL4: 100, commissionL5: 100, commissionL6: 100, commissionL7: 2250, isActive: "true" },
          { name: "Holistic Health Program", category: "holistic", description: "Holistic veteran health", commissionType: "percentage", commissionL1: 6900, commissionL2: 100, commissionL3: 100, commissionL4: 100, commissionL5: 100, commissionL6: 100, commissionL7: 2250, isActive: "true" },
          { name: "Tax Credit Services", category: "tax_credits", description: "Business tax credit", commissionType: "flat", commissionL1: 50000, commissionL2: 2000, commissionL3: 2000, commissionL4: 2000, commissionL5: 2000, commissionL6: 2000, commissionL7: 15000, isActive: "true" },
          { name: "Insurance Package", category: "insurance", description: "Veteran insurance", commissionType: "percentage", commissionL1: 6900, commissionL2: 100, commissionL3: 100, commissionL4: 100, commissionL5: 100, commissionL6: 100, commissionL7: 2250, isActive: "true" },
        ];
        for (const opp of testOpportunities) {
          await storage.createOpportunity(opp);
        }
        existingOpportunities = await storage.getAllOpportunities();
      }
      
      // Step 2: Check for existing stress test affiliates or create new ones
      const allAffiliates = await storage.getAllVltAffiliates();
      let stressTestAffiliates = allAffiliates.filter(a => a.email.includes("@stresstest.nav"));
      
      // If we have existing stress test affiliates, use them; otherwise create new ones
      if (stressTestAffiliates.length === 0) {
        const hashedPassword = await hashPassword("TestPass123!");
        const subMasterCount = Math.max(1, Math.floor(affiliateCount * 0.15)); // 15% are sub_masters
        const createdAffiliates: any[] = [];
        
        for (let i = 0; i < affiliateCount; i++) {
          const firstName = firstNames[Math.floor(Math.random() * firstNames.length)];
          const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
          const rank = militaryRanks[Math.floor(Math.random() * militaryRanks.length)];
          const role = i === 0 ? "master" : (i < subMasterCount ? "sub_master" : "affiliate");
          
          // Build hierarchy with configurable randomness
          const getRandomParent = (maxIdx: number) => {
            if (maxIdx <= 0) return null;
            const structuredIdx = Math.min(i - 1, maxIdx - 1);
            const randomIdx = Math.floor(Math.random() * maxIdx);
            const blendedIdx = Math.round(structuredIdx * (1 - randomness) + randomIdx * randomness);
            return createdAffiliates[Math.min(blendedIdx, maxIdx - 1)]?.id || null;
          };
          
          const level1Id = i > 0 ? getRandomParent(Math.min(i, subMasterCount + 2)) : null;
          const level2Id = i > 1 ? getRandomParent(Math.min(i, subMasterCount)) : null;
          const level3Id = i > 2 ? getRandomParent(Math.min(i, Math.max(2, subMasterCount - 1))) : null;
          const level4Id = i > 3 ? getRandomParent(Math.min(i, 3)) : null;
          const level5Id = i > 4 ? getRandomParent(2) : null;
          const level6Id = createdAffiliates[0]?.id || null;
          
          try {
            const affiliate = await storage.createVltAffiliate({
              name: `${rank} ${firstName} ${lastName}`,
              email: `test.${firstName.toLowerCase()}.${lastName.toLowerCase()}.${i}@stresstest.nav`,
              phone: `555-${String(Math.floor(Math.random() * 900) + 100)}-${String(Math.floor(Math.random() * 9000) + 1000)}`,
              passwordHash: hashedPassword,
              referralCode: `STRESS${i.toString().padStart(3, "0")}`,
              role,
              level1Id,
              level2Id,
              level3Id,
              level4Id,
              level5Id,
              level6Id,
              level7Id: null,
              recruiterId: i > 0 ? createdAffiliates[Math.floor(Math.random() * i)].id : null,
              status: "active",
              isCompActive: Math.random() > 0.2 ? "true" : "false",
              totalSales: 0,
              totalCommissions: 0,
              totalRecruiterBounties: 0,
            });
            createdAffiliates.push(affiliate);
          } catch (e) {
            console.log(`Skipping duplicate affiliate ${i}`);
          }
        }
        stressTestAffiliates = createdAffiliates;
      }
      
      // Step 3: Create sales with commissions (using salesCount)
      const salesCreated: any[] = [];
      const commissionsCreated: any[] = [];
      
      // Use stress test affiliates for sales
      if (stressTestAffiliates.length === 0) {
        return res.status(400).json({ message: "No affiliates available for stress test. Please clear data and try again." });
      }
      
      for (let i = 0; i < salesCount; i++) {
        const affiliate = stressTestAffiliates[Math.floor(Math.random() * stressTestAffiliates.length)];
        const opportunity = existingOpportunities[Math.floor(Math.random() * existingOpportunities.length)];
        // Median sale for tax is $16,000 - create distribution around this
        // Range: $5,000 - $35,000 with median around $16,000
        const baseAmount = 1600000; // $16,000 in cents (median)
        const variance = Math.floor((Math.random() - 0.5) * 2 * 1900000); // +/- $19,000 variance
        const saleAmount = Math.max(500000, baseAmount + variance); // Min $5,000
        const status = statuses[Math.floor(Math.random() * statuses.length)];
        
        const clientFirstName = firstNames[Math.floor(Math.random() * firstNames.length)];
        const clientLastName = lastNames[Math.floor(Math.random() * lastNames.length)];
        
        try {
          const sale = await storage.createSale({
            opportunityId: opportunity.id,
            affiliateId: affiliate.id,
            clientName: `${clientFirstName} ${clientLastName}`,
            clientEmail: `${clientFirstName.toLowerCase()}.${clientLastName.toLowerCase()}@client.com`,
            clientPhone: `555-${String(Math.floor(Math.random() * 900) + 100)}-${String(Math.floor(Math.random() * 9000) + 1000)}`,
            saleAmount,
            referredByL1: affiliate.id,
            referredByL2: affiliate.level1Id,
            referredByL3: affiliate.level2Id,
            referredByL4: affiliate.level3Id,
            referredByL5: affiliate.level4Id,
            referredByL6: affiliate.level5Id,
            referredByL7: affiliate.level6Id,
            recruiterId: affiliate.recruiterId,
            recruiterBounty: Math.floor(saleAmount * 0.025),
            l2Active: affiliate.isCompActive,
            l3Active: "true",
            l4Active: "true",
            l5Active: "true",
            compressedToL6: 0,
            notes: `Stress test sale #${i + 1}`,
          });
          
          // Update sale status
          await storage.updateSale(sale.id, { status });
          salesCreated.push({ ...sale, status });
          
          // Create commissions for each level
          const commissionPool = saleAmount;
          const commissionRates = [0.69, 0.01, 0.01, 0.01, 0.01, 0.01, 0.225]; // Producer + 6 uplines + house
          
          // Level 1 - Producer
          if (affiliate.id) {
            const comm = await storage.createCommission({
              saleId: sale.id,
              affiliateId: affiliate.id,
              level: 1,
              amount: Math.floor(commissionPool * commissionRates[0]),
            });
            await storage.updateCommission(comm.id, { status });
            commissionsCreated.push(comm);
          }
          
          // Levels 2-6 uplines
          const uplineIds = [affiliate.level1Id, affiliate.level2Id, affiliate.level3Id, affiliate.level4Id, affiliate.level5Id];
          for (let lvl = 0; lvl < uplineIds.length; lvl++) {
            if (uplineIds[lvl]) {
              const comm = await storage.createCommission({
                saleId: sale.id,
                affiliateId: uplineIds[lvl],
                level: lvl + 2,
                amount: Math.floor(commissionPool * commissionRates[lvl + 1]),
              });
              await storage.updateCommission(comm.id, { status });
              commissionsCreated.push(comm);
            }
          }
        } catch (e) {
          console.log(`Error creating sale ${i}:`, e);
        }
      }
      
      res.json({
        success: true,
        message: "Stress test simulation completed",
        stats: {
          affiliatesUsed: stressTestAffiliates.length,
          salesCreated: salesCreated.length,
          commissionsCreated: commissionsCreated.length,
          totalSalesVolume: salesCreated.reduce((sum, s) => sum + s.saleAmount, 0),
          totalCommissions: commissionsCreated.reduce((sum, c) => sum + c.amount, 0),
        },
      });
    } catch (error) {
      console.error("Error running stress test:", error);
      res.status(500).json({ message: "Failed to run stress test simulation" });
    }
  });
  
  // Get stress test results
  // Public endpoint for demo purposes
  app.get("/api/stress-test/results", async (req, res) => {
    try {
      const affiliates = await storage.getAllVltAffiliates();
      const allSales = await storage.getAllSales();
      const opportunities = await storage.getAllOpportunities();
      
      // Get commissions for each affiliate
      const affiliateData = await Promise.all(affiliates.map(async (aff) => {
        const affSales = allSales.filter(s => s.affiliateId === aff.id);
        const affCommissions = await storage.getCommissionsByAffiliate(aff.id);
        
        return {
          id: aff.id,
          name: aff.name,
          email: aff.email,
          role: aff.role,
          referralCode: aff.referralCode,
          status: aff.status,
          isCompActive: aff.isCompActive,
          level1Id: aff.level1Id,
          level2Id: aff.level2Id,
          level3Id: aff.level3Id,
          totalDirectSales: affSales.length,
          totalSalesVolume: affSales.reduce((sum, s) => sum + s.saleAmount, 0),
          totalCommissionsEarned: affCommissions.reduce((sum, c) => sum + c.amount, 0),
          pendingCommissions: affCommissions.filter(c => c.status === "pending").reduce((sum, c) => sum + c.amount, 0),
          approvedCommissions: affCommissions.filter(c => c.status === "approved").reduce((sum, c) => sum + c.amount, 0),
          paidCommissions: affCommissions.filter(c => c.status === "paid").reduce((sum, c) => sum + c.amount, 0),
          commissionsByLevel: {
            level1: affCommissions.filter(c => c.level === 1).reduce((sum, c) => sum + c.amount, 0),
            level2: affCommissions.filter(c => c.level === 2).reduce((sum, c) => sum + c.amount, 0),
            level3: affCommissions.filter(c => c.level === 3).reduce((sum, c) => sum + c.amount, 0),
            level4: affCommissions.filter(c => c.level === 4).reduce((sum, c) => sum + c.amount, 0),
            level5: affCommissions.filter(c => c.level === 5).reduce((sum, c) => sum + c.amount, 0),
            level6: affCommissions.filter(c => c.level === 6).reduce((sum, c) => sum + c.amount, 0),
          },
        };
      }));
      
      // Summary stats
      const summary = {
        totalAffiliates: affiliates.length,
        totalSales: allSales.length,
        totalSalesVolume: allSales.reduce((sum, s) => sum + s.saleAmount, 0),
        salesByStatus: {
          pending: allSales.filter(s => s.status === "pending").length,
          approved: allSales.filter(s => s.status === "approved").length,
          paid: allSales.filter(s => s.status === "paid").length,
        },
        affiliatesByRole: {
          master: affiliates.filter(a => a.role === "master").length,
          sub_master: affiliates.filter(a => a.role === "sub_master").length,
          affiliate: affiliates.filter(a => a.role === "affiliate").length,
        },
        averageSaleAmount: allSales.length > 0 ? Math.floor(allSales.reduce((sum, s) => sum + s.saleAmount, 0) / allSales.length) : 0,
        topPerformers: affiliateData.sort((a, b) => b.totalCommissionsEarned - a.totalCommissionsEarned).slice(0, 10),
      };
      
      res.json({
        summary,
        affiliates: affiliateData,
        opportunities,
      });
    } catch (error) {
      console.error("Error fetching stress test results:", error);
      res.status(500).json({ message: "Failed to fetch stress test results" });
    }
  });
  
  // Clear stress test data
  // Public endpoint for demo purposes
  app.delete("/api/stress-test/clear", async (req, res) => {
    try {
      // This would need a storage method to clear test data
      // For safety, we only clear affiliates with @stresstest.nav emails
      const affiliates = await storage.getAllVltAffiliates();
      const testAffiliates = affiliates.filter(a => a.email.includes("@stresstest.nav"));
      
      for (const aff of testAffiliates) {
        // Delete commissions for this affiliate
        const commissions = await storage.getCommissionsByAffiliate(aff.id);
        for (const comm of commissions) {
          // Would need delete commission method
        }
        // Delete sales by this affiliate
        const sales = await storage.getSalesByAffiliate(aff.id);
        for (const sale of sales) {
          // Would need delete sale method
        }
        // Delete the affiliate
        await storage.deleteVltAffiliate(aff.id);
      }
      
      res.json({ 
        success: true, 
        message: `Cleared ${testAffiliates.length} test affiliates and their data` 
      });
    } catch (error) {
      console.error("Error clearing stress test data:", error);
      res.status(500).json({ message: "Failed to clear stress test data" });
    }
  });

  // Schedule A Signature Routes
  
  // Check if current user has signed Schedule A
  app.get("/api/schedule-a/status", requireAuth, async (req, res) => {
    try {
      const signature = await storage.getScheduleASignatureByUserId(req.session.userId!);
      res.json({ 
        signed: !!signature, 
        signature: signature || null 
      });
    } catch (error) {
      console.error("Error checking Schedule A status:", error);
      res.status(500).json({ message: "Failed to check signature status" });
    }
  });

  // Sign Schedule A
  app.post("/api/schedule-a/sign", requireAuth, async (req, res) => {
    try {
      const user = await storage.getUserById(req.session.userId!);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const existingSignature = await storage.getScheduleASignatureByUserId(req.session.userId!);
      if (existingSignature) {
        return res.status(400).json({ message: "Schedule A already signed" });
      }

      const uplineCount = typeof req.body.uplineCount === 'number' ? req.body.uplineCount : 0;
      if (uplineCount < 0 || uplineCount > 6) {
        return res.status(400).json({ message: "Invalid upline count. Must be between 0 and 6." });
      }

      const forwardedFor = req.headers['x-forwarded-for'];
      const clientIp = req.ip || (Array.isArray(forwardedFor) ? forwardedFor[0] : forwardedFor?.split(',')[0]?.trim()) || 'unknown';

      const validatedData = insertScheduleASignatureSchema.parse({
        userId: req.session.userId!,
        affiliateName: user.name,
        affiliateEmail: user.email,
        ipAddress: clientIp,
        userAgent: req.headers['user-agent'] || 'unknown',
        acknowledgedUplineCount: uplineCount,
        version: "1.0"
      });

      const signature = await storage.createScheduleASignature(validatedData);
      res.json({ success: true, signature });
    } catch (error) {
      console.error("Error signing Schedule A:", error);
      res.status(500).json({ message: "Failed to sign Schedule A" });
    }
  });

  // Admin: Get all Schedule A signatures
  app.get("/api/admin/schedule-a-signatures", requireAdmin, async (req, res) => {
    try {
      const signatures = await storage.getAllScheduleASignatures();
      res.json(signatures);
    } catch (error) {
      console.error("Error fetching Schedule A signatures:", error);
      res.status(500).json({ message: "Failed to fetch signatures" });
    }
  });

  // Insurance Intake Routes
  
  // Public: Submit insurance intake
  app.post("/api/insurance-intakes", async (req, res) => {
    try {
      const validatedData = insertInsuranceIntakeSchema.parse(req.body);
      const intake = await storage.createInsuranceIntake(validatedData);
      res.json({ success: true, intake });
    } catch (error) {
      console.error("Error creating insurance intake:", error);
      res.status(500).json({ message: "Failed to submit insurance request" });
    }
  });

  // Admin: Get all insurance intakes
  app.get("/api/admin/insurance-intakes", requireAdmin, async (req, res) => {
    try {
      const intakes = await storage.getAllInsuranceIntakes();
      res.json(intakes);
    } catch (error) {
      console.error("Error fetching insurance intakes:", error);
      res.status(500).json({ message: "Failed to fetch insurance intakes" });
    }
  });

  // Admin: Update insurance intake
  app.patch("/api/admin/insurance-intakes/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const intake = await storage.updateInsuranceIntake(id, updates);
      res.json(intake);
    } catch (error) {
      console.error("Error updating insurance intake:", error);
      res.status(500).json({ message: "Failed to update insurance intake" });
    }
  });

  // Medical Sales Intake Routes
  app.post("/api/medical-sales-intakes", async (req, res) => {
    try {
      const validatedData = insertMedicalSalesIntakeSchema.parse(req.body);
      const intake = await storage.createMedicalSalesIntake(validatedData);
      res.json({ success: true, intake });
    } catch (error) {
      console.error("Error creating medical sales intake:", error);
      res.status(500).json({ message: "Failed to submit medical sales inquiry" });
    }
  });

  app.get("/api/admin/medical-sales-intakes", requireAdmin, async (req, res) => {
    try {
      const intakes = await storage.getAllMedicalSalesIntakes();
      res.json(intakes);
    } catch (error) {
      console.error("Error fetching medical sales intakes:", error);
      res.status(500).json({ message: "Failed to fetch medical sales intakes" });
    }
  });

  app.patch("/api/admin/medical-sales-intakes/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const intake = await storage.updateMedicalSalesIntake(id, updates);
      res.json(intake);
    } catch (error) {
      console.error("Error updating medical sales intake:", error);
      res.status(500).json({ message: "Failed to update medical sales intake" });
    }
  });

  app.get("/api/affiliate/medical-sales-intakes", requireAffiliate, async (req, res) => {
    try {
      const intakes = await storage.getMedicalSalesIntakesByAffiliate(req.session.userId!);
      res.json(intakes);
    } catch (error) {
      console.error("Error fetching affiliate medical sales intakes:", error);
      res.status(500).json({ message: "Failed to fetch medical sales intakes" });
    }
  });

  // Business Development Intake Routes
  app.post("/api/business-dev-intakes", async (req, res) => {
    try {
      const validatedData = insertBusinessDevIntakeSchema.parse(req.body);
      const intake = await storage.createBusinessDevIntake(validatedData);
      res.json({ success: true, intake });
    } catch (error) {
      console.error("Error creating business dev intake:", error);
      res.status(500).json({ message: "Failed to submit business development inquiry" });
    }
  });

  app.get("/api/admin/business-dev-intakes", requireAdmin, async (req, res) => {
    try {
      const intakes = await storage.getAllBusinessDevIntakes();
      res.json(intakes);
    } catch (error) {
      console.error("Error fetching business dev intakes:", error);
      res.status(500).json({ message: "Failed to fetch business development intakes" });
    }
  });

  app.patch("/api/admin/business-dev-intakes/:id", requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const intake = await storage.updateBusinessDevIntake(id, updates);
      res.json(intake);
    } catch (error) {
      console.error("Error updating business dev intake:", error);
      res.status(500).json({ message: "Failed to update business development intake" });
    }
  });

  app.get("/api/affiliate/business-dev-intakes", requireAffiliate, async (req, res) => {
    try {
      const intakes = await storage.getBusinessDevIntakesByAffiliate(req.session.userId!);
      res.json(intakes);
    } catch (error) {
      console.error("Error fetching affiliate business dev intakes:", error);
      res.status(500).json({ message: "Failed to fetch business development intakes" });
    }
  });

  return httpServer;
}


========== STORAGE LAYER ==========


import { 
  users, type User, type InsertUser,
  affiliateApplications, type AffiliateApplication, type InsertAffiliateApplication,
  helpRequests, type HelpRequest, type InsertHelpRequest,
  startupGrants, type StartupGrant, type InsertStartupGrant,
  furnitureAssistance, type FurnitureAssistance, type InsertFurnitureAssistance,
  investorSubmissions, type InvestorSubmission, type InsertInvestorSubmission,
  privateDoctorRequests, type PrivateDoctorRequest, type InsertPrivateDoctorRequest,
  websiteApplications, type WebsiteApplication, type InsertWebsiteApplication,
  generalContact, type GeneralContact, type InsertGeneralContact,
  vltIntake, type VltIntake, type InsertVltIntake,
  vltAffiliates, type VltAffiliate, type InsertVltAffiliate,
  opportunities, type Opportunity, type InsertOpportunity,
  sales, type Sale, type InsertSale,
  commissions, type Commission, type InsertCommission,
  veteranIntake, type VeteranIntake, type InsertVeteranIntake,
  businessIntake, type BusinessIntake, type InsertBusinessIntake,
  contractTemplates, type ContractTemplate, type InsertContractTemplate,
  signedAgreements, type SignedAgreement, type InsertSignedAgreement,
  commissionConfig, type CommissionConfig, type InsertCommissionConfig,
  affiliateNda, type AffiliateNda, type InsertAffiliateNda,
  businessLeads, type BusinessLead, type InsertBusinessLead,
  ipReferralTracking, type IpReferralTracking, type InsertIpReferralTracking,
  affiliateW9, type AffiliateW9, type InsertAffiliateW9,
  finopsReferrals, type FinopsReferral, type InsertFinopsReferral,
  disabilityReferrals, type DisabilityReferral, type InsertDisabilityReferral,
  jobPlacementIntakes, type JobPlacementIntake, type InsertJobPlacementIntake,
  vetProfessionalIntakes, type VetProfessionalIntake, type InsertVetProfessionalIntake,
  healthcareIntakes, type HealthcareIntake, type InsertHealthcareIntake,
  scheduleASignatures, type ScheduleASignature, type InsertScheduleASignature,
  insuranceIntakes, type InsuranceIntake, type InsertInsuranceIntake,
  medicalSalesIntakes, type MedicalSalesIntake, type InsertMedicalSalesIntake,
  businessDevIntakes, type BusinessDevIntake, type InsertBusinessDevIntake
} from "@shared/schema";
import { db } from "./db";
import { eq, desc, and, isNull, or, ilike, gt } from "drizzle-orm";

export interface IStorage {
  // Users
  getUser(id: number): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  getUserByReferralCode(code: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  getAllAffiliates(): Promise<User[]>;
  updateUserPassword(id: number, passwordHash: string): Promise<User | undefined>;
  updateUserReferralCode(id: number, referralCode: string): Promise<User | undefined>;
  deleteUser(id: number): Promise<void>;

  // Affiliate Applications
  createAffiliateApplication(app: InsertAffiliateApplication): Promise<AffiliateApplication>;
  getAffiliateApplication(id: number): Promise<AffiliateApplication | undefined>;
  getAllAffiliateApplications(): Promise<AffiliateApplication[]>;
  getAffiliateApplicationsByAssignee(userId: number): Promise<AffiliateApplication[]>;
  updateAffiliateApplication(id: number, updates: Partial<AffiliateApplication>): Promise<AffiliateApplication | undefined>;

  // Help Requests
  createHelpRequest(req: InsertHelpRequest): Promise<HelpRequest>;
  getHelpRequest(id: number): Promise<HelpRequest | undefined>;
  getAllHelpRequests(): Promise<HelpRequest[]>;
  getHelpRequestsByAssignee(userId: number): Promise<HelpRequest[]>;
  updateHelpRequest(id: number, updates: Partial<HelpRequest>): Promise<HelpRequest | undefined>;

  // Startup Grants
  createStartupGrant(grant: InsertStartupGrant): Promise<StartupGrant>;
  getStartupGrant(id: number): Promise<StartupGrant | undefined>;
  getAllStartupGrants(): Promise<StartupGrant[]>;
  getStartupGrantsByAssignee(userId: number): Promise<StartupGrant[]>;
  updateStartupGrant(id: number, updates: Partial<StartupGrant>): Promise<StartupGrant | undefined>;

  // Furniture Assistance
  createFurnitureAssistance(req: InsertFurnitureAssistance): Promise<FurnitureAssistance>;
  getFurnitureAssistance(id: number): Promise<FurnitureAssistance | undefined>;
  getAllFurnitureAssistance(): Promise<FurnitureAssistance[]>;
  getFurnitureAssistanceByAssignee(userId: number): Promise<FurnitureAssistance[]>;
  updateFurnitureAssistance(id: number, updates: Partial<FurnitureAssistance>): Promise<FurnitureAssistance | undefined>;

  // Investor Submissions
  createInvestorSubmission(submission: InsertInvestorSubmission): Promise<InvestorSubmission>;
  getInvestorSubmission(id: number): Promise<InvestorSubmission | undefined>;
  getAllInvestorSubmissions(): Promise<InvestorSubmission[]>;
  getInvestorSubmissionsByAssignee(userId: number): Promise<InvestorSubmission[]>;
  updateInvestorSubmission(id: number, updates: Partial<InvestorSubmission>): Promise<InvestorSubmission | undefined>;

  // Private Doctor Requests
  createPrivateDoctorRequest(req: InsertPrivateDoctorRequest): Promise<PrivateDoctorRequest>;
  getPrivateDoctorRequest(id: number): Promise<PrivateDoctorRequest | undefined>;
  getAllPrivateDoctorRequests(): Promise<PrivateDoctorRequest[]>;
  getPrivateDoctorRequestsByAssignee(userId: number): Promise<PrivateDoctorRequest[]>;
  updatePrivateDoctorRequest(id: number, updates: Partial<PrivateDoctorRequest>): Promise<PrivateDoctorRequest | undefined>;

  // Website Applications
  createWebsiteApplication(app: InsertWebsiteApplication): Promise<WebsiteApplication>;
  getWebsiteApplication(id: number): Promise<WebsiteApplication | undefined>;
  getAllWebsiteApplications(): Promise<WebsiteApplication[]>;
  getWebsiteApplicationsByAssignee(userId: number): Promise<WebsiteApplication[]>;
  updateWebsiteApplication(id: number, updates: Partial<WebsiteApplication>): Promise<WebsiteApplication | undefined>;

  // General Contact
  createGeneralContact(contact: InsertGeneralContact): Promise<GeneralContact>;
  getGeneralContact(id: number): Promise<GeneralContact | undefined>;
  getAllGeneralContacts(): Promise<GeneralContact[]>;
  getGeneralContactsByAssignee(userId: number): Promise<GeneralContact[]>;
  updateGeneralContact(id: number, updates: Partial<GeneralContact>): Promise<GeneralContact | undefined>;

  // VLT Intake
  createVltIntake(intake: InsertVltIntake): Promise<VltIntake>;
  getVltIntake(id: number): Promise<VltIntake | undefined>;
  getAllVltIntakes(): Promise<VltIntake[]>;
  updateVltIntake(id: number, updates: Partial<VltIntake>): Promise<VltIntake | undefined>;
  getVltIntakesByAffiliate(affiliateId: number): Promise<VltIntake[]>;

  // VLT Affiliates
  createVltAffiliate(affiliate: InsertVltAffiliate): Promise<VltAffiliate>;
  getVltAffiliate(id: number): Promise<VltAffiliate | undefined>;
  getVltAffiliateByEmail(email: string): Promise<VltAffiliate | undefined>;
  getVltAffiliateByReferralCode(code: string): Promise<VltAffiliate | undefined>;
  getAllVltAffiliates(): Promise<VltAffiliate[]>;
  getVltAffiliatesByRole(role: string): Promise<VltAffiliate[]>;
  getVltAffiliateDownline(affiliateId: number): Promise<VltAffiliate[]>;
  updateVltAffiliate(id: number, updates: Partial<VltAffiliate>): Promise<VltAffiliate | undefined>;
  deleteVltAffiliate(id: number): Promise<void>;

  // Opportunities
  createOpportunity(opp: InsertOpportunity): Promise<Opportunity>;
  getOpportunity(id: number): Promise<Opportunity | undefined>;
  getAllOpportunities(): Promise<Opportunity[]>;
  getOpportunitiesByCategory(category: string): Promise<Opportunity[]>;
  updateOpportunity(id: number, updates: Partial<Opportunity>): Promise<Opportunity | undefined>;

  // Sales
  createSale(sale: InsertSale): Promise<Sale>;
  getSale(id: number): Promise<Sale | undefined>;
  getAllSales(): Promise<Sale[]>;
  getSalesByAffiliate(affiliateId: number): Promise<Sale[]>;
  getSalesByDownline(affiliateId: number): Promise<Sale[]>;
  updateSale(id: number, updates: Partial<Sale>): Promise<Sale | undefined>;

  // Commissions
  createCommission(commission: InsertCommission): Promise<Commission>;
  getCommission(id: number): Promise<Commission | undefined>;
  getCommissionsByAffiliate(affiliateId: number): Promise<Commission[]>;
  getCommissionsBySale(saleId: number): Promise<Commission[]>;
  updateCommission(id: number, updates: Partial<Commission>): Promise<Commission | undefined>;

  // Veteran Intake
  createVeteranIntake(intake: InsertVeteranIntake): Promise<VeteranIntake>;
  getVeteranIntake(id: number): Promise<VeteranIntake | undefined>;
  getAllVeteranIntakes(): Promise<VeteranIntake[]>;
  getVeteranIntakesByProgram(programType: string): Promise<VeteranIntake[]>;
  updateVeteranIntake(id: number, updates: Partial<VeteranIntake>): Promise<VeteranIntake | undefined>;

  // Business Intake
  createBusinessIntake(intake: InsertBusinessIntake): Promise<BusinessIntake>;
  getBusinessIntake(id: number): Promise<BusinessIntake | undefined>;
  getAllBusinessIntakes(): Promise<BusinessIntake[]>;
  getBusinessIntakesByService(serviceType: string): Promise<BusinessIntake[]>;
  updateBusinessIntake(id: number, updates: Partial<BusinessIntake>): Promise<BusinessIntake | undefined>;

  // Contract Templates
  createContractTemplate(template: InsertContractTemplate): Promise<ContractTemplate>;
  getContractTemplate(id: number): Promise<ContractTemplate | undefined>;
  getAllContractTemplates(): Promise<ContractTemplate[]>;
  getActiveContractTemplates(): Promise<ContractTemplate[]>;
  updateContractTemplate(id: number, updates: Partial<ContractTemplate>): Promise<ContractTemplate | undefined>;

  // Signed Agreements
  createSignedAgreement(agreement: InsertSignedAgreement): Promise<SignedAgreement>;
  getSignedAgreement(id: number): Promise<SignedAgreement | undefined>;
  getAllSignedAgreements(): Promise<SignedAgreement[]>;
  getSignedAgreementsByAffiliate(affiliateId: number): Promise<SignedAgreement[]>;
  hasAffiliateSignedContract(affiliateId: number, contractTemplateId: number): Promise<boolean>;
  updateSignedAgreement(id: number, updates: Partial<SignedAgreement>): Promise<SignedAgreement | undefined>;

  // Commission Config
  createCommissionConfig(config: InsertCommissionConfig): Promise<CommissionConfig>;
  getActiveCommissionConfig(): Promise<CommissionConfig | undefined>;
  updateCommissionConfig(id: number, updates: Partial<CommissionConfig>): Promise<CommissionConfig | undefined>;

  // Affiliate NDA
  createAffiliateNda(nda: InsertAffiliateNda): Promise<AffiliateNda>;
  getAffiliateNdaByUserId(userId: number): Promise<AffiliateNda | undefined>;
  getAffiliateNdaById(id: number): Promise<AffiliateNda | undefined>;
  hasAffiliateSignedNda(userId: number): Promise<boolean>;
  getAllAffiliateNdas(): Promise<AffiliateNda[]>;

  // Business Leads
  createBusinessLead(lead: InsertBusinessLead): Promise<BusinessLead>;
  getBusinessLead(id: number): Promise<BusinessLead | undefined>;
  getAllBusinessLeads(): Promise<BusinessLead[]>;
  getBusinessLeadsByType(leadType: string): Promise<BusinessLead[]>;
  getBusinessLeadsByReferrer(referredBy: number): Promise<BusinessLead[]>;
  updateBusinessLead(id: number, updates: Partial<BusinessLead>): Promise<BusinessLead | undefined>;

  // IP Referral Tracking
  createIpReferralTracking(data: InsertIpReferralTracking): Promise<IpReferralTracking>;
  getActiveIpReferral(ipAddress: string): Promise<IpReferralTracking | undefined>;
  getIpReferralsByAffiliate(affiliateId: number): Promise<IpReferralTracking[]>;
  getAllIpReferrals(): Promise<IpReferralTracking[]>;

  // W9 Forms
  createAffiliateW9(w9: InsertAffiliateW9): Promise<AffiliateW9>;
  getAffiliateW9ByUserId(userId: number): Promise<AffiliateW9 | undefined>;
  hasAffiliateSubmittedW9(userId: number): Promise<boolean>;
  getAllAffiliateW9s(): Promise<AffiliateW9[]>;

  // Fin-Ops Referral Tracking
  createFinopsReferral(referral: InsertFinopsReferral): Promise<FinopsReferral>;
  getFinopsReferral(id: number): Promise<FinopsReferral | undefined>;
  getAllFinopsReferrals(): Promise<FinopsReferral[]>;
  getFinopsReferralsByAffiliate(affiliateId: number): Promise<FinopsReferral[]>;
  getFinopsReferralsByPartnerType(partnerType: string): Promise<FinopsReferral[]>;
  updateFinopsReferral(id: number, updates: Partial<FinopsReferral>): Promise<FinopsReferral | undefined>;

  // Disability Referral Tracking
  createDisabilityReferral(referral: InsertDisabilityReferral): Promise<DisabilityReferral>;
  getDisabilityReferral(id: number): Promise<DisabilityReferral | undefined>;
  getAllDisabilityReferrals(): Promise<DisabilityReferral[]>;
  getDisabilityReferralsByAffiliate(affiliateId: number): Promise<DisabilityReferral[]>;
  updateDisabilityReferral(id: number, updates: Partial<DisabilityReferral>): Promise<DisabilityReferral | undefined>;
  getDisabilityReferralStats(): Promise<{ total: number; byType: Record<string, number>; byStatus: Record<string, number> }>;

  // Schedule A Signatures
  createScheduleASignature(signature: InsertScheduleASignature): Promise<ScheduleASignature>;
  getScheduleASignatureByUserId(userId: number): Promise<ScheduleASignature | undefined>;
  getAllScheduleASignatures(): Promise<ScheduleASignature[]>;

  // Insurance Intakes
  createInsuranceIntake(intake: InsertInsuranceIntake): Promise<InsuranceIntake>;
  getAllInsuranceIntakes(): Promise<InsuranceIntake[]>;
  updateInsuranceIntake(id: number, updates: Partial<InsuranceIntake>): Promise<InsuranceIntake | undefined>;

  // Medical Sales Intakes
  createMedicalSalesIntake(intake: InsertMedicalSalesIntake): Promise<MedicalSalesIntake>;
  getAllMedicalSalesIntakes(): Promise<MedicalSalesIntake[]>;
  getMedicalSalesIntakesByAffiliate(affiliateId: number): Promise<MedicalSalesIntake[]>;
  updateMedicalSalesIntake(id: number, updates: Partial<MedicalSalesIntake>): Promise<MedicalSalesIntake | undefined>;

  // Business Development Intakes
  createBusinessDevIntake(intake: InsertBusinessDevIntake): Promise<BusinessDevIntake>;
  getAllBusinessDevIntakes(): Promise<BusinessDevIntake[]>;
  getBusinessDevIntakesByAffiliate(affiliateId: number): Promise<BusinessDevIntake[]>;
  updateBusinessDevIntake(id: number, updates: Partial<BusinessDevIntake>): Promise<BusinessDevIntake | undefined>;
}

export class DatabaseStorage implements IStorage {
  // Users
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user || undefined;
  }

  async getUserByReferralCode(code: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.referralCode, code));
    return user || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db.insert(users).values(insertUser).returning();
    return user;
  }

  async getAllAffiliates(): Promise<User[]> {
    return db.select().from(users).where(eq(users.role, "affiliate")).orderBy(desc(users.createdAt));
  }

  async updateUserPassword(id: number, passwordHash: string): Promise<User | undefined> {
    const [user] = await db.update(users).set({ passwordHash }).where(eq(users.id, id)).returning();
    return user || undefined;
  }

  async updateUserReferralCode(id: number, referralCode: string): Promise<User | undefined> {
    const [user] = await db.update(users).set({ referralCode }).where(eq(users.id, id)).returning();
    return user || undefined;
  }

  async deleteUser(id: number): Promise<void> {
    await db.delete(users).where(eq(users.id, id));
  }

  // Affiliate Applications
  async createAffiliateApplication(app: InsertAffiliateApplication): Promise<AffiliateApplication> {
    const [application] = await db.insert(affiliateApplications).values(app).returning();
    return application;
  }

  async getAffiliateApplication(id: number): Promise<AffiliateApplication | undefined> {
    const [app] = await db.select().from(affiliateApplications).where(eq(affiliateApplications.id, id));
    return app || undefined;
  }

  async getAllAffiliateApplications(): Promise<AffiliateApplication[]> {
    return db.select().from(affiliateApplications).orderBy(desc(affiliateApplications.createdAt));
  }

  async getAffiliateApplicationsByAssignee(userId: number): Promise<AffiliateApplication[]> {
    return db.select().from(affiliateApplications)
      .where(eq(affiliateApplications.assignedTo, userId))
      .orderBy(desc(affiliateApplications.createdAt));
  }

  async updateAffiliateApplication(id: number, updates: Partial<AffiliateApplication>): Promise<AffiliateApplication | undefined> {
    const [app] = await db.update(affiliateApplications)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(affiliateApplications.id, id))
      .returning();
    return app || undefined;
  }

  // Help Requests
  async createHelpRequest(req: InsertHelpRequest): Promise<HelpRequest> {
    const [request] = await db.insert(helpRequests).values(req).returning();
    return request;
  }

  async getHelpRequest(id: number): Promise<HelpRequest | undefined> {
    const [req] = await db.select().from(helpRequests).where(eq(helpRequests.id, id));
    return req || undefined;
  }

  async getAllHelpRequests(): Promise<HelpRequest[]> {
    return db.select().from(helpRequests).orderBy(desc(helpRequests.createdAt));
  }

  async getHelpRequestsByAssignee(userId: number): Promise<HelpRequest[]> {
    return db.select().from(helpRequests)
      .where(eq(helpRequests.assignedTo, userId))
      .orderBy(desc(helpRequests.createdAt));
  }

  async updateHelpRequest(id: number, updates: Partial<HelpRequest>): Promise<HelpRequest | undefined> {
    const [req] = await db.update(helpRequests)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(helpRequests.id, id))
      .returning();
    return req || undefined;
  }

  // Startup Grants
  async createStartupGrant(grant: InsertStartupGrant): Promise<StartupGrant> {
    const [result] = await db.insert(startupGrants).values(grant).returning();
    return result;
  }

  async getStartupGrant(id: number): Promise<StartupGrant | undefined> {
    const [grant] = await db.select().from(startupGrants).where(eq(startupGrants.id, id));
    return grant || undefined;
  }

  async getAllStartupGrants(): Promise<StartupGrant[]> {
    return db.select().from(startupGrants).orderBy(desc(startupGrants.createdAt));
  }

  async getStartupGrantsByAssignee(userId: number): Promise<StartupGrant[]> {
    return db.select().from(startupGrants)
      .where(eq(startupGrants.assignedTo, userId))
      .orderBy(desc(startupGrants.createdAt));
  }

  async updateStartupGrant(id: number, updates: Partial<StartupGrant>): Promise<StartupGrant | undefined> {
    const [grant] = await db.update(startupGrants)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(startupGrants.id, id))
      .returning();
    return grant || undefined;
  }

  // Furniture Assistance
  async createFurnitureAssistance(req: InsertFurnitureAssistance): Promise<FurnitureAssistance> {
    const [result] = await db.insert(furnitureAssistance).values(req).returning();
    return result;
  }

  async getFurnitureAssistance(id: number): Promise<FurnitureAssistance | undefined> {
    const [req] = await db.select().from(furnitureAssistance).where(eq(furnitureAssistance.id, id));
    return req || undefined;
  }

  async getAllFurnitureAssistance(): Promise<FurnitureAssistance[]> {
    return db.select().from(furnitureAssistance).orderBy(desc(furnitureAssistance.createdAt));
  }

  async getFurnitureAssistanceByAssignee(userId: number): Promise<FurnitureAssistance[]> {
    return db.select().from(furnitureAssistance)
      .where(eq(furnitureAssistance.assignedTo, userId))
      .orderBy(desc(furnitureAssistance.createdAt));
  }

  async updateFurnitureAssistance(id: number, updates: Partial<FurnitureAssistance>): Promise<FurnitureAssistance | undefined> {
    const [req] = await db.update(furnitureAssistance)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(furnitureAssistance.id, id))
      .returning();
    return req || undefined;
  }

  // Investor Submissions
  async createInvestorSubmission(submission: InsertInvestorSubmission): Promise<InvestorSubmission> {
    const [result] = await db.insert(investorSubmissions).values(submission).returning();
    return result;
  }

  async getInvestorSubmission(id: number): Promise<InvestorSubmission | undefined> {
    const [submission] = await db.select().from(investorSubmissions).where(eq(investorSubmissions.id, id));
    return submission || undefined;
  }

  async getAllInvestorSubmissions(): Promise<InvestorSubmission[]> {
    return db.select().from(investorSubmissions).orderBy(desc(investorSubmissions.createdAt));
  }

  async getInvestorSubmissionsByAssignee(userId: number): Promise<InvestorSubmission[]> {
    return db.select().from(investorSubmissions)
      .where(eq(investorSubmissions.assignedTo, userId))
      .orderBy(desc(investorSubmissions.createdAt));
  }

  async updateInvestorSubmission(id: number, updates: Partial<InvestorSubmission>): Promise<InvestorSubmission | undefined> {
    const [submission] = await db.update(investorSubmissions)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(investorSubmissions.id, id))
      .returning();
    return submission || undefined;
  }

  // Private Doctor Requests
  async createPrivateDoctorRequest(req: InsertPrivateDoctorRequest): Promise<PrivateDoctorRequest> {
    const [result] = await db.insert(privateDoctorRequests).values(req).returning();
    return result;
  }

  async getPrivateDoctorRequest(id: number): Promise<PrivateDoctorRequest | undefined> {
    const [req] = await db.select().from(privateDoctorRequests).where(eq(privateDoctorRequests.id, id));
    return req || undefined;
  }

  async getAllPrivateDoctorRequests(): Promise<PrivateDoctorRequest[]> {
    return db.select().from(privateDoctorRequests).orderBy(desc(privateDoctorRequests.createdAt));
  }

  async getPrivateDoctorRequestsByAssignee(userId: number): Promise<PrivateDoctorRequest[]> {
    return db.select().from(privateDoctorRequests)
      .where(eq(privateDoctorRequests.assignedTo, userId))
      .orderBy(desc(privateDoctorRequests.createdAt));
  }

  async updatePrivateDoctorRequest(id: number, updates: Partial<PrivateDoctorRequest>): Promise<PrivateDoctorRequest | undefined> {
    const [req] = await db.update(privateDoctorRequests)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(privateDoctorRequests.id, id))
      .returning();
    return req || undefined;
  }

  // Website Applications
  async createWebsiteApplication(app: InsertWebsiteApplication): Promise<WebsiteApplication> {
    const [result] = await db.insert(websiteApplications).values(app).returning();
    return result;
  }

  async getWebsiteApplication(id: number): Promise<WebsiteApplication | undefined> {
    const [app] = await db.select().from(websiteApplications).where(eq(websiteApplications.id, id));
    return app || undefined;
  }

  async getAllWebsiteApplications(): Promise<WebsiteApplication[]> {
    return db.select().from(websiteApplications).orderBy(desc(websiteApplications.createdAt));
  }

  async getWebsiteApplicationsByAssignee(userId: number): Promise<WebsiteApplication[]> {
    return db.select().from(websiteApplications)
      .where(eq(websiteApplications.assignedTo, userId))
      .orderBy(desc(websiteApplications.createdAt));
  }

  async updateWebsiteApplication(id: number, updates: Partial<WebsiteApplication>): Promise<WebsiteApplication | undefined> {
    const [app] = await db.update(websiteApplications)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(websiteApplications.id, id))
      .returning();
    return app || undefined;
  }

  // General Contact
  async createGeneralContact(contact: InsertGeneralContact): Promise<GeneralContact> {
    const [result] = await db.insert(generalContact).values(contact).returning();
    return result;
  }

  async getGeneralContact(id: number): Promise<GeneralContact | undefined> {
    const [contact] = await db.select().from(generalContact).where(eq(generalContact.id, id));
    return contact || undefined;
  }

  async getAllGeneralContacts(): Promise<GeneralContact[]> {
    return db.select().from(generalContact).orderBy(desc(generalContact.createdAt));
  }

  async getGeneralContactsByAssignee(userId: number): Promise<GeneralContact[]> {
    return db.select().from(generalContact)
      .where(eq(generalContact.assignedTo, userId))
      .orderBy(desc(generalContact.createdAt));
  }

  async updateGeneralContact(id: number, updates: Partial<GeneralContact>): Promise<GeneralContact | undefined> {
    const [contact] = await db.update(generalContact)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(generalContact.id, id))
      .returning();
    return contact || undefined;
  }

  // VLT Intake
  async createVltIntake(intake: InsertVltIntake): Promise<VltIntake> {
    // Lead routing logic based on issue type
    const routedTo =
      intake.issue === "credits" ? "CPA" :
      intake.issue === "resolution" ? "Tax Attorney" :
      "General";

    console.log("NEW LEAD:", {
      ...intake,
      routedTo,
      timestamp: new Date().toISOString()
    });

    const [result] = await db.insert(vltIntake).values({ ...intake, routedTo }).returning();
    return result;
  }

  async getVltIntake(id: number): Promise<VltIntake | undefined> {
    const [intake] = await db.select().from(vltIntake).where(eq(vltIntake.id, id));
    return intake || undefined;
  }

  async getAllVltIntakes(): Promise<VltIntake[]> {
    return db.select().from(vltIntake).orderBy(desc(vltIntake.createdAt));
  }

  async updateVltIntake(id: number, updates: Partial<VltIntake>): Promise<VltIntake | undefined> {
    const [intake] = await db.update(vltIntake)
      .set(updates)
      .where(eq(vltIntake.id, id))
      .returning();
    return intake || undefined;
  }

  async getVltIntakesByAffiliate(affiliateId: number): Promise<VltIntake[]> {
    return db.select().from(vltIntake)
      .where(or(
        eq(vltIntake.referredByL1, affiliateId),
        eq(vltIntake.referredByL2, affiliateId),
        eq(vltIntake.referredByL3, affiliateId),
        eq(vltIntake.referredByL4, affiliateId),
        eq(vltIntake.referredByL5, affiliateId),
        eq(vltIntake.referredByL6, affiliateId)
      ))
      .orderBy(desc(vltIntake.createdAt));
  }

  // VLT Affiliates
  async createVltAffiliate(affiliate: InsertVltAffiliate): Promise<VltAffiliate> {
    const [result] = await db.insert(vltAffiliates).values(affiliate).returning();
    return result;
  }

  async getVltAffiliate(id: number): Promise<VltAffiliate | undefined> {
    const [affiliate] = await db.select().from(vltAffiliates).where(eq(vltAffiliates.id, id));
    return affiliate || undefined;
  }

  async getVltAffiliateByEmail(email: string): Promise<VltAffiliate | undefined> {
    const [affiliate] = await db.select().from(vltAffiliates).where(eq(vltAffiliates.email, email));
    return affiliate || undefined;
  }

  async getVltAffiliateByReferralCode(code: string): Promise<VltAffiliate | undefined> {
    const [affiliate] = await db.select().from(vltAffiliates).where(eq(vltAffiliates.referralCode, code));
    return affiliate || undefined;
  }

  async getAllVltAffiliates(): Promise<VltAffiliate[]> {
    return db.select().from(vltAffiliates).orderBy(desc(vltAffiliates.createdAt));
  }

  async updateVltAffiliate(id: number, updates: Partial<VltAffiliate>): Promise<VltAffiliate | undefined> {
    const [affiliate] = await db.update(vltAffiliates)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(vltAffiliates.id, id))
      .returning();
    return affiliate || undefined;
  }

  async deleteVltAffiliate(id: number): Promise<void> {
    await db.delete(vltAffiliates).where(eq(vltAffiliates.id, id));
  }

  async getVltAffiliatesByRole(role: string): Promise<VltAffiliate[]> {
    return db.select().from(vltAffiliates).where(eq(vltAffiliates.role, role)).orderBy(desc(vltAffiliates.createdAt));
  }

  async getVltAffiliateDownline(affiliateId: number): Promise<VltAffiliate[]> {
    return db.select().from(vltAffiliates).where(
      or(
        eq(vltAffiliates.level1Id, affiliateId),
        eq(vltAffiliates.level2Id, affiliateId),
        eq(vltAffiliates.level3Id, affiliateId),
        eq(vltAffiliates.level4Id, affiliateId),
        eq(vltAffiliates.level5Id, affiliateId),
        eq(vltAffiliates.level6Id, affiliateId),
        eq(vltAffiliates.level7Id, affiliateId)
      )
    ).orderBy(desc(vltAffiliates.createdAt));
  }

  // Opportunities
  async createOpportunity(opp: InsertOpportunity): Promise<Opportunity> {
    const [result] = await db.insert(opportunities).values(opp).returning();
    return result;
  }

  async getOpportunity(id: number): Promise<Opportunity | undefined> {
    const [opp] = await db.select().from(opportunities).where(eq(opportunities.id, id));
    return opp || undefined;
  }

  async getAllOpportunities(): Promise<Opportunity[]> {
    return db.select().from(opportunities).orderBy(desc(opportunities.createdAt));
  }

  async getOpportunitiesByCategory(category: string): Promise<Opportunity[]> {
    return db.select().from(opportunities).where(eq(opportunities.category, category)).orderBy(desc(opportunities.createdAt));
  }

  async updateOpportunity(id: number, updates: Partial<Opportunity>): Promise<Opportunity | undefined> {
    const [opp] = await db.update(opportunities).set(updates).where(eq(opportunities.id, id)).returning();
    return opp || undefined;
  }

  // Sales
  async createSale(sale: InsertSale): Promise<Sale> {
    const [result] = await db.insert(sales).values(sale).returning();
    return result;
  }

  async getSale(id: number): Promise<Sale | undefined> {
    const [sale] = await db.select().from(sales).where(eq(sales.id, id));
    return sale || undefined;
  }

  async getAllSales(): Promise<Sale[]> {
    return db.select().from(sales).orderBy(desc(sales.createdAt));
  }

  async getSalesByAffiliate(affiliateId: number): Promise<Sale[]> {
    return db.select().from(sales).where(eq(sales.affiliateId, affiliateId)).orderBy(desc(sales.createdAt));
  }

  async getSalesByDownline(affiliateId: number): Promise<Sale[]> {
    return db.select().from(sales).where(
      or(
        eq(sales.referredByL1, affiliateId),
        eq(sales.referredByL2, affiliateId),
        eq(sales.referredByL3, affiliateId),
        eq(sales.referredByL4, affiliateId),
        eq(sales.referredByL5, affiliateId),
        eq(sales.referredByL6, affiliateId),
        eq(sales.referredByL7, affiliateId)
      )
    ).orderBy(desc(sales.createdAt));
  }

  async updateSale(id: number, updates: Partial<Sale>): Promise<Sale | undefined> {
    const [sale] = await db.update(sales).set({ ...updates, updatedAt: new Date() }).where(eq(sales.id, id)).returning();
    return sale || undefined;
  }

  // Commissions
  async createCommission(commission: InsertCommission): Promise<Commission> {
    const [result] = await db.insert(commissions).values(commission).returning();
    return result;
  }

  async getCommission(id: number): Promise<Commission | undefined> {
    const [comm] = await db.select().from(commissions).where(eq(commissions.id, id));
    return comm || undefined;
  }

  async getCommissionsByAffiliate(affiliateId: number): Promise<Commission[]> {
    return db.select().from(commissions).where(eq(commissions.affiliateId, affiliateId)).orderBy(desc(commissions.createdAt));
  }

  async getCommissionsBySale(saleId: number): Promise<Commission[]> {
    return db.select().from(commissions).where(eq(commissions.saleId, saleId)).orderBy(desc(commissions.createdAt));
  }

  async updateCommission(id: number, updates: Partial<Commission>): Promise<Commission | undefined> {
    const [comm] = await db.update(commissions).set(updates).where(eq(commissions.id, id)).returning();
    return comm || undefined;
  }

  // Veteran Intake
  async createVeteranIntake(intake: InsertVeteranIntake): Promise<VeteranIntake> {
    const [result] = await db.insert(veteranIntake).values(intake).returning();
    return result;
  }

  async getVeteranIntake(id: number): Promise<VeteranIntake | undefined> {
    const [vi] = await db.select().from(veteranIntake).where(eq(veteranIntake.id, id));
    return vi || undefined;
  }

  async getAllVeteranIntakes(): Promise<VeteranIntake[]> {
    return db.select().from(veteranIntake).orderBy(desc(veteranIntake.createdAt));
  }

  async getVeteranIntakesByProgram(programType: string): Promise<VeteranIntake[]> {
    return db.select().from(veteranIntake).where(eq(veteranIntake.programType, programType)).orderBy(desc(veteranIntake.createdAt));
  }

  async updateVeteranIntake(id: number, updates: Partial<VeteranIntake>): Promise<VeteranIntake | undefined> {
    const [vi] = await db.update(veteranIntake).set({ ...updates, updatedAt: new Date() }).where(eq(veteranIntake.id, id)).returning();
    return vi || undefined;
  }

  // Business Intake
  async createBusinessIntake(intake: InsertBusinessIntake): Promise<BusinessIntake> {
    const [result] = await db.insert(businessIntake).values(intake).returning();
    return result;
  }

  async getBusinessIntake(id: number): Promise<BusinessIntake | undefined> {
    const [bi] = await db.select().from(businessIntake).where(eq(businessIntake.id, id));
    return bi || undefined;
  }

  async getAllBusinessIntakes(): Promise<BusinessIntake[]> {
    return db.select().from(businessIntake).orderBy(desc(businessIntake.createdAt));
  }

  async getBusinessIntakesByService(serviceType: string): Promise<BusinessIntake[]> {
    return db.select().from(businessIntake).where(eq(businessIntake.serviceType, serviceType)).orderBy(desc(businessIntake.createdAt));
  }

  async updateBusinessIntake(id: number, updates: Partial<BusinessIntake>): Promise<BusinessIntake | undefined> {
    const [bi] = await db.update(businessIntake).set({ ...updates, updatedAt: new Date() }).where(eq(businessIntake.id, id)).returning();
    return bi || undefined;
  }

  // Contract Templates
  async createContractTemplate(template: InsertContractTemplate): Promise<ContractTemplate> {
    const [result] = await db.insert(contractTemplates).values(template).returning();
    return result;
  }

  async getContractTemplate(id: number): Promise<ContractTemplate | undefined> {
    const [ct] = await db.select().from(contractTemplates).where(eq(contractTemplates.id, id));
    return ct || undefined;
  }

  async getAllContractTemplates(): Promise<ContractTemplate[]> {
    return db.select().from(contractTemplates).orderBy(desc(contractTemplates.createdAt));
  }

  async getActiveContractTemplates(): Promise<ContractTemplate[]> {
    return db.select().from(contractTemplates).where(eq(contractTemplates.isActive, "true")).orderBy(desc(contractTemplates.createdAt));
  }

  async updateContractTemplate(id: number, updates: Partial<ContractTemplate>): Promise<ContractTemplate | undefined> {
    const [ct] = await db.update(contractTemplates).set({ ...updates, updatedAt: new Date() }).where(eq(contractTemplates.id, id)).returning();
    return ct || undefined;
  }

  // Signed Agreements
  async createSignedAgreement(agreement: InsertSignedAgreement): Promise<SignedAgreement> {
    const [result] = await db.insert(signedAgreements).values(agreement).returning();
    return result;
  }

  async getSignedAgreement(id: number): Promise<SignedAgreement | undefined> {
    const [sa] = await db.select().from(signedAgreements).where(eq(signedAgreements.id, id));
    return sa || undefined;
  }

  async getAllSignedAgreements(): Promise<SignedAgreement[]> {
    return db.select().from(signedAgreements).orderBy(desc(signedAgreements.signedAt));
  }

  async getSignedAgreementsByAffiliate(affiliateId: number): Promise<SignedAgreement[]> {
    return db.select().from(signedAgreements).where(eq(signedAgreements.affiliateId, affiliateId)).orderBy(desc(signedAgreements.signedAt));
  }

  async hasAffiliateSignedContract(affiliateId: number, contractTemplateId: number): Promise<boolean> {
    const [sa] = await db.select().from(signedAgreements)
      .where(and(
        eq(signedAgreements.affiliateId, affiliateId),
        eq(signedAgreements.contractTemplateId, contractTemplateId),
        eq(signedAgreements.status, "signed")
      ));
    return !!sa;
  }

  async updateSignedAgreement(id: number, updates: Partial<SignedAgreement>): Promise<SignedAgreement | undefined> {
    const [sa] = await db.update(signedAgreements).set(updates).where(eq(signedAgreements.id, id)).returning();
    return sa || undefined;
  }

  // Commission Config
  async createCommissionConfig(config: InsertCommissionConfig): Promise<CommissionConfig> {
    const [c] = await db.insert(commissionConfig).values(config).returning();
    return c;
  }

  async getActiveCommissionConfig(): Promise<CommissionConfig | undefined> {
    const [config] = await db.select().from(commissionConfig).where(eq(commissionConfig.isActive, "true")).orderBy(desc(commissionConfig.createdAt)).limit(1);
    return config || undefined;
  }

  async updateCommissionConfig(id: number, updates: Partial<CommissionConfig>): Promise<CommissionConfig | undefined> {
    const [config] = await db.update(commissionConfig).set({ ...updates, updatedAt: new Date() }).where(eq(commissionConfig.id, id)).returning();
    return config || undefined;
  }

  // Affiliate NDA
  async createAffiliateNda(nda: InsertAffiliateNda): Promise<AffiliateNda> {
    const [created] = await db.insert(affiliateNda).values(nda).returning();
    return created;
  }

  async getAffiliateNdaByUserId(userId: number): Promise<AffiliateNda | undefined> {
    const [nda] = await db.select().from(affiliateNda).where(eq(affiliateNda.userId, userId));
    return nda || undefined;
  }

  async getAffiliateNdaById(id: number): Promise<AffiliateNda | undefined> {
    const [nda] = await db.select().from(affiliateNda).where(eq(affiliateNda.id, id));
    return nda || undefined;
  }

  async hasAffiliateSignedNda(userId: number): Promise<boolean> {
    const nda = await this.getAffiliateNdaByUserId(userId);
    return !!nda;
  }

  async getAllAffiliateNdas(): Promise<AffiliateNda[]> {
    return db.select().from(affiliateNda).orderBy(desc(affiliateNda.signedAt));
  }

  // Business Leads
  async createBusinessLead(lead: InsertBusinessLead): Promise<BusinessLead> {
    const [created] = await db.insert(businessLeads).values(lead).returning();
    return created;
  }

  async getBusinessLead(id: number): Promise<BusinessLead | undefined> {
    const [lead] = await db.select().from(businessLeads).where(eq(businessLeads.id, id));
    return lead || undefined;
  }

  async getAllBusinessLeads(): Promise<BusinessLead[]> {
    return db.select().from(businessLeads).orderBy(desc(businessLeads.createdAt));
  }

  async getBusinessLeadsByType(leadType: string): Promise<BusinessLead[]> {
    return db.select().from(businessLeads).where(eq(businessLeads.leadType, leadType)).orderBy(desc(businessLeads.createdAt));
  }

  async getBusinessLeadsByReferrer(referredBy: number): Promise<BusinessLead[]> {
    return db.select().from(businessLeads).where(eq(businessLeads.referredBy, referredBy)).orderBy(desc(businessLeads.createdAt));
  }

  async updateBusinessLead(id: number, updates: Partial<BusinessLead>): Promise<BusinessLead | undefined> {
    const [updated] = await db.update(businessLeads).set({ ...updates, updatedAt: new Date() }).where(eq(businessLeads.id, id)).returning();
    return updated || undefined;
  }

  // IP Referral Tracking
  async createIpReferralTracking(data: InsertIpReferralTracking): Promise<IpReferralTracking> {
    const [created] = await db.insert(ipReferralTracking).values(data).returning();
    return created;
  }

  async getActiveIpReferral(ipAddress: string): Promise<IpReferralTracking | undefined> {
    const now = new Date();
    const [tracking] = await db.select().from(ipReferralTracking)
      .where(and(
        eq(ipReferralTracking.ipAddress, ipAddress),
        gt(ipReferralTracking.expiresAt, now)
      ))
      .orderBy(desc(ipReferralTracking.createdAt))
      .limit(1);
    return tracking || undefined;
  }

  async getIpReferralsByAffiliate(affiliateId: number): Promise<IpReferralTracking[]> {
    return db.select().from(ipReferralTracking)
      .where(eq(ipReferralTracking.affiliateId, affiliateId))
      .orderBy(desc(ipReferralTracking.createdAt));
  }

  async getAllIpReferrals(): Promise<IpReferralTracking[]> {
    return db.select().from(ipReferralTracking)
      .orderBy(desc(ipReferralTracking.createdAt));
  }

  // W9 Forms
  async createAffiliateW9(w9: InsertAffiliateW9): Promise<AffiliateW9> {
    const [created] = await db.insert(affiliateW9).values(w9).returning();
    return created;
  }

  async getAffiliateW9ByUserId(userId: number): Promise<AffiliateW9 | undefined> {
    const [w9] = await db.select().from(affiliateW9).where(eq(affiliateW9.userId, userId));
    return w9 || undefined;
  }

  async hasAffiliateSubmittedW9(userId: number): Promise<boolean> {
    const w9 = await this.getAffiliateW9ByUserId(userId);
    return !!w9;
  }

  async getAllAffiliateW9s(): Promise<AffiliateW9[]> {
    return await db.select().from(affiliateW9);
  }

  // Fin-Ops Referral Tracking
  async createFinopsReferral(referral: InsertFinopsReferral): Promise<FinopsReferral> {
    const [created] = await db.insert(finopsReferrals).values(referral).returning();
    return created;
  }

  async getFinopsReferral(id: number): Promise<FinopsReferral | undefined> {
    const [referral] = await db.select().from(finopsReferrals).where(eq(finopsReferrals.id, id));
    return referral || undefined;
  }

  async getAllFinopsReferrals(): Promise<FinopsReferral[]> {
    return db.select().from(finopsReferrals).orderBy(desc(finopsReferrals.createdAt));
  }

  async getFinopsReferralsByAffiliate(affiliateId: number): Promise<FinopsReferral[]> {
    return db.select().from(finopsReferrals)
      .where(eq(finopsReferrals.affiliateId, affiliateId))
      .orderBy(desc(finopsReferrals.createdAt));
  }

  async getFinopsReferralsByPartnerType(partnerType: string): Promise<FinopsReferral[]> {
    return db.select().from(finopsReferrals)
      .where(eq(finopsReferrals.partnerType, partnerType))
      .orderBy(desc(finopsReferrals.createdAt));
  }

  async updateFinopsReferral(id: number, updates: Partial<FinopsReferral>): Promise<FinopsReferral | undefined> {
    const [updated] = await db.update(finopsReferrals)
      .set(updates)
      .where(eq(finopsReferrals.id, id))
      .returning();
    return updated || undefined;
  }

  // Disability Referral Tracking
  async createDisabilityReferral(referral: InsertDisabilityReferral): Promise<DisabilityReferral> {
    const [created] = await db.insert(disabilityReferrals).values(referral).returning();
    return created;
  }

  async getDisabilityReferral(id: number): Promise<DisabilityReferral | undefined> {
    const [referral] = await db.select().from(disabilityReferrals).where(eq(disabilityReferrals.id, id));
    return referral || undefined;
  }

  async getAllDisabilityReferrals(): Promise<DisabilityReferral[]> {
    return db.select().from(disabilityReferrals).orderBy(desc(disabilityReferrals.createdAt));
  }

  async getDisabilityReferralsByAffiliate(affiliateId: number): Promise<DisabilityReferral[]> {
    return db.select().from(disabilityReferrals)
      .where(eq(disabilityReferrals.affiliateId, affiliateId))
      .orderBy(desc(disabilityReferrals.createdAt));
  }

  async updateDisabilityReferral(id: number, updates: Partial<DisabilityReferral>): Promise<DisabilityReferral | undefined> {
    const [updated] = await db.update(disabilityReferrals)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(disabilityReferrals.id, id))
      .returning();
    return updated || undefined;
  }

  async getDisabilityReferralStats(): Promise<{ total: number; byType: Record<string, number>; byStatus: Record<string, number> }> {
    const all = await db.select().from(disabilityReferrals);
    const byType: Record<string, number> = {};
    const byStatus: Record<string, number> = {};
    
    for (const ref of all) {
      byType[ref.claimType] = (byType[ref.claimType] || 0) + 1;
      byStatus[ref.status] = (byStatus[ref.status] || 0) + 1;
    }
    
    return { total: all.length, byType, byStatus };
  }

  // Job Placement Intakes
  async createJobPlacementIntake(intake: InsertJobPlacementIntake): Promise<JobPlacementIntake> {
    const [created] = await db.insert(jobPlacementIntakes).values(intake).returning();
    return created;
  }

  async getJobPlacementIntake(id: number): Promise<JobPlacementIntake | undefined> {
    const [intake] = await db.select().from(jobPlacementIntakes).where(eq(jobPlacementIntakes.id, id));
    return intake || undefined;
  }

  async getAllJobPlacementIntakes(): Promise<JobPlacementIntake[]> {
    return db.select().from(jobPlacementIntakes).orderBy(desc(jobPlacementIntakes.createdAt));
  }

  async getJobPlacementIntakesByAffiliate(affiliateId: number): Promise<JobPlacementIntake[]> {
    return db.select().from(jobPlacementIntakes)
      .where(eq(jobPlacementIntakes.affiliateId, affiliateId))
      .orderBy(desc(jobPlacementIntakes.createdAt));
  }

  async updateJobPlacementIntake(id: number, updates: Partial<JobPlacementIntake>): Promise<JobPlacementIntake | undefined> {
    const [updated] = await db.update(jobPlacementIntakes)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(jobPlacementIntakes.id, id))
      .returning();
    return updated || undefined;
  }

  // Vet Professional Intakes
  async createVetProfessionalIntake(intake: InsertVetProfessionalIntake): Promise<VetProfessionalIntake> {
    const [created] = await db.insert(vetProfessionalIntakes).values(intake).returning();
    return created;
  }

  async getVetProfessionalIntake(id: number): Promise<VetProfessionalIntake | undefined> {
    const [intake] = await db.select().from(vetProfessionalIntakes).where(eq(vetProfessionalIntakes.id, id));
    return intake || undefined;
  }

  async getAllVetProfessionalIntakes(): Promise<VetProfessionalIntake[]> {
    return db.select().from(vetProfessionalIntakes).orderBy(desc(vetProfessionalIntakes.createdAt));
  }

  async getVetProfessionalIntakesByAffiliate(affiliateId: number): Promise<VetProfessionalIntake[]> {
    return db.select().from(vetProfessionalIntakes)
      .where(eq(vetProfessionalIntakes.affiliateId, affiliateId))
      .orderBy(desc(vetProfessionalIntakes.createdAt));
  }

  async updateVetProfessionalIntake(id: number, updates: Partial<VetProfessionalIntake>): Promise<VetProfessionalIntake | undefined> {
    const [updated] = await db.update(vetProfessionalIntakes)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(vetProfessionalIntakes.id, id))
      .returning();
    return updated || undefined;
  }

  // Healthcare Intakes
  async createHealthcareIntake(intake: InsertHealthcareIntake): Promise<HealthcareIntake> {
    const [created] = await db.insert(healthcareIntakes).values(intake).returning();
    return created;
  }

  async getAllHealthcareIntakes(): Promise<HealthcareIntake[]> {
    return db.select().from(healthcareIntakes).orderBy(desc(healthcareIntakes.createdAt));
  }

  async updateHealthcareIntake(id: number, updates: Partial<HealthcareIntake>): Promise<HealthcareIntake | undefined> {
    const [updated] = await db.update(healthcareIntakes)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(healthcareIntakes.id, id))
      .returning();
    return updated || undefined;
  }

  // Schedule A Signatures
  async createScheduleASignature(signature: InsertScheduleASignature): Promise<ScheduleASignature> {
    const [created] = await db.insert(scheduleASignatures).values(signature).returning();
    return created;
  }

  async getScheduleASignatureByUserId(userId: number): Promise<ScheduleASignature | undefined> {
    const [signature] = await db.select().from(scheduleASignatures)
      .where(eq(scheduleASignatures.userId, userId));
    return signature || undefined;
  }

  async getAllScheduleASignatures(): Promise<ScheduleASignature[]> {
    return db.select().from(scheduleASignatures).orderBy(desc(scheduleASignatures.signedAt));
  }

  // Insurance Intakes
  async createInsuranceIntake(intake: InsertInsuranceIntake): Promise<InsuranceIntake> {
    const [created] = await db.insert(insuranceIntakes).values(intake).returning();
    return created;
  }

  async getAllInsuranceIntakes(): Promise<InsuranceIntake[]> {
    return db.select().from(insuranceIntakes).orderBy(desc(insuranceIntakes.createdAt));
  }

  async updateInsuranceIntake(id: number, updates: Partial<InsuranceIntake>): Promise<InsuranceIntake | undefined> {
    const [updated] = await db.update(insuranceIntakes)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(insuranceIntakes.id, id))
      .returning();
    return updated || undefined;
  }

  // Medical Sales Intakes
  async createMedicalSalesIntake(intake: InsertMedicalSalesIntake): Promise<MedicalSalesIntake> {
    const [created] = await db.insert(medicalSalesIntakes).values(intake).returning();
    return created;
  }

  async getAllMedicalSalesIntakes(): Promise<MedicalSalesIntake[]> {
    return db.select().from(medicalSalesIntakes).orderBy(desc(medicalSalesIntakes.createdAt));
  }

  async getMedicalSalesIntakesByAffiliate(affiliateId: number): Promise<MedicalSalesIntake[]> {
    return db.select().from(medicalSalesIntakes)
      .where(eq(medicalSalesIntakes.assignedTo, affiliateId))
      .orderBy(desc(medicalSalesIntakes.createdAt));
  }

  async updateMedicalSalesIntake(id: number, updates: Partial<MedicalSalesIntake>): Promise<MedicalSalesIntake | undefined> {
    const [updated] = await db.update(medicalSalesIntakes)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(medicalSalesIntakes.id, id))
      .returning();
    return updated || undefined;
  }

  // Business Development Intakes
  async createBusinessDevIntake(intake: InsertBusinessDevIntake): Promise<BusinessDevIntake> {
    const [created] = await db.insert(businessDevIntakes).values(intake).returning();
    return created;
  }

  async getAllBusinessDevIntakes(): Promise<BusinessDevIntake[]> {
    return db.select().from(businessDevIntakes).orderBy(desc(businessDevIntakes.createdAt));
  }

  async getBusinessDevIntakesByAffiliate(affiliateId: number): Promise<BusinessDevIntake[]> {
    return db.select().from(businessDevIntakes)
      .where(eq(businessDevIntakes.assignedTo, affiliateId))
      .orderBy(desc(businessDevIntakes.createdAt));
  }

  async updateBusinessDevIntake(id: number, updates: Partial<BusinessDevIntake>): Promise<BusinessDevIntake | undefined> {
    const [updated] = await db.update(businessDevIntakes)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(businessDevIntakes.id, id))
      .returning();
    return updated || undefined;
  }

  async getUserById(id: number): Promise<User | undefined> {
    return this.getUser(id);
  }
}

export const storage = new DatabaseStorage();


========== DATABASE SCHEMA ==========


import { sql } from "drizzle-orm";
import { pgTable, text, varchar, integer, timestamp, serial, boolean } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Users table (Admin and Affiliate)
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  passwordHash: text("password_hash").notNull(),
  role: text("role").notNull(), // "admin" or "affiliate"
  referralCode: text("referral_code").unique(), // Unique referral code for affiliates
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertUserSchema = createInsertSchema(users).omit({
  id: true,
  createdAt: true,
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

// Affiliate Applications
export const affiliateApplications = pgTable("affiliate_applications", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  companyName: text("company_name").notNull(),
  phone: text("phone").notNull(),
  email: text("email").notNull(),
  description: text("description").notNull(),
  status: text("status").notNull().default("new"), // new, contacted, in_progress, closed
  assignedTo: integer("assigned_to").references(() => users.id),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertAffiliateApplicationSchema = createInsertSchema(affiliateApplications).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertAffiliateApplication = z.infer<typeof insertAffiliateApplicationSchema>;
export type AffiliateApplication = typeof affiliateApplications.$inferSelect;

// Help Requests
export const helpRequests = pgTable("help_requests", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  phone: text("phone").notNull(),
  email: text("email").notNull(),
  helpType: text("help_type").notNull(), // disability_denial, appeal, low_rating, exam_issues, service_connection, other
  otherHelpType: text("other_help_type"),
  description: text("description").notNull(),
  status: text("status").notNull().default("new"), // new, contacted, in_progress, closed
  assignedTo: integer("assigned_to").references(() => users.id),
  referredBy: integer("referred_by").references(() => users.id), // Affiliate who referred this lead
  referralCode: text("referral_code"), // The referral code used
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertHelpRequestSchema = createInsertSchema(helpRequests).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertHelpRequest = z.infer<typeof insertHelpRequestSchema>;
export type HelpRequest = typeof helpRequests.$inferSelect;

// Startup Grant Applications
export const startupGrants = pgTable("startup_grants", {
  id: serial("id").primaryKey(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  branch: text("branch").notNull(),
  serviceStatus: text("service_status").notNull(),
  businessName: text("business_name").notNull(),
  industry: text("industry").notNull(),
  businessDescription: text("business_description").notNull(),
  fundingNeeds: text("funding_needs").notNull(),
  grantAmount: text("grant_amount").notNull(),
  status: text("status").notNull().default("new"),
  assignedTo: integer("assigned_to").references(() => users.id),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertStartupGrantSchema = createInsertSchema(startupGrants).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertStartupGrant = z.infer<typeof insertStartupGrantSchema>;
export type StartupGrant = typeof startupGrants.$inferSelect;

// Furniture Assistance Requests
export const furnitureAssistance = pgTable("furniture_assistance", {
  id: serial("id").primaryKey(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  branch: text("branch").notNull(),
  serviceStatus: text("service_status").notNull(),
  homeStatus: text("home_status").notNull(),
  expectedCloseDate: text("expected_close_date"),
  homeLocation: text("home_location"),
  additionalInfo: text("additional_info"),
  status: text("status").notNull().default("new"),
  assignedTo: integer("assigned_to").references(() => users.id),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertFurnitureAssistanceSchema = createInsertSchema(furnitureAssistance).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertFurnitureAssistance = z.infer<typeof insertFurnitureAssistanceSchema>;
export type FurnitureAssistance = typeof furnitureAssistance.$inferSelect;

// Investor Submissions
export const investorSubmissions = pgTable("investor_submissions", {
  id: serial("id").primaryKey(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  companyName: text("company_name"),
  investmentInterest: text("investment_interest").notNull(),
  investmentRange: text("investment_range").notNull(),
  message: text("message"),
  status: text("status").notNull().default("new"),
  assignedTo: integer("assigned_to").references(() => users.id),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertInvestorSubmissionSchema = createInsertSchema(investorSubmissions).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertInvestorSubmission = z.infer<typeof insertInvestorSubmissionSchema>;
export type InvestorSubmission = typeof investorSubmissions.$inferSelect;

// Private Doctor Requests
export const privateDoctorRequests = pgTable("private_doctor_requests", {
  id: serial("id").primaryKey(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  zip: text("zip").notNull(),
  branch: text("branch").notNull(),
  careType: text("care_type").notNull(),
  situation: text("situation"),
  status: text("status").notNull().default("new"),
  assignedTo: integer("assigned_to").references(() => users.id),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertPrivateDoctorRequestSchema = createInsertSchema(privateDoctorRequests).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertPrivateDoctorRequest = z.infer<typeof insertPrivateDoctorRequestSchema>;
export type PrivateDoctorRequest = typeof privateDoctorRequests.$inferSelect;

// Website Applications
export const websiteApplications = pgTable("website_applications", {
  id: serial("id").primaryKey(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  branch: text("branch").notNull(),
  serviceStatus: text("service_status").notNull(),
  businessName: text("business_name").notNull(),
  industry: text("industry").notNull(),
  description: text("description").notNull(),
  websiteNeeds: text("website_needs"),
  status: text("status").notNull().default("new"),
  assignedTo: integer("assigned_to").references(() => users.id),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertWebsiteApplicationSchema = createInsertSchema(websiteApplications).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertWebsiteApplication = z.infer<typeof insertWebsiteApplicationSchema>;
export type WebsiteApplication = typeof websiteApplications.$inferSelect;

// General Contact Submissions
export const generalContact = pgTable("general_contact", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  subject: text("subject").notNull(),
  message: text("message").notNull(),
  status: text("status").notNull().default("new"),
  assignedTo: integer("assigned_to").references(() => users.id),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertGeneralContactSchema = createInsertSchema(generalContact).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertGeneralContact = z.infer<typeof insertGeneralContactSchema>;
export type GeneralContact = typeof generalContact.$inferSelect;

// VLT Affiliates with 6-level hierarchy (new comp model)
// Note: level7Id kept for legacy compatibility, new model uses L1-L6 only
export const vltAffiliates = pgTable("vlt_affiliates", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  phone: text("phone"),
  passwordHash: text("password_hash").notNull(),
  referralCode: text("referral_code").notNull().unique(),
  role: text("role").notNull().default("affiliate"), // master, sub_master, affiliate
  level1Id: integer("level1_id"), // Direct upline (closest upline - L2 in comp model)
  level2Id: integer("level2_id"), // 2nd level upline (L3 in comp model)
  level3Id: integer("level3_id"), // 3rd level upline (L4 in comp model)
  level4Id: integer("level4_id"), // 4th level upline (L5 in comp model)
  level5Id: integer("level5_id"), // 5th level upline (Company - L6 in comp model)
  level6Id: integer("level6_id"), // Legacy - maps to L6/Company
  level7Id: integer("level7_id"), // Legacy - kept for backward compatibility
  recruiterId: integer("recruiter_id"), // Who recruited this affiliate (for 2.5% bounty)
  status: text("status").notNull().default("active"), // active, inactive, suspended
  isCompActive: text("is_comp_active").notNull().default("true"), // For compression logic
  totalLeads: integer("total_leads").default(0),
  totalSales: integer("total_sales").default(0),
  totalCommissions: integer("total_commissions").default(0), // cents
  totalRecruiterBounties: integer("total_recruiter_bounties").default(0), // cents
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Opportunities/Services (modular - B2B and B2C)
export const opportunities = pgTable("opportunities", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  category: text("category").notNull(), // disability, holistic, healthcare, insurance, tax_credits, sales, b2b, b2c
  description: text("description"),
  commissionType: text("commission_type").notNull().default("percentage"), // percentage, flat
  commissionL1: integer("commission_l1").default(0), // Level 1 commission (percentage x100 or cents)
  commissionL2: integer("commission_l2").default(0),
  commissionL3: integer("commission_l3").default(0),
  commissionL4: integer("commission_l4").default(0),
  commissionL5: integer("commission_l5").default(0),
  commissionL6: integer("commission_l6").default(0),
  commissionL7: integer("commission_l7").default(0),
  isActive: text("is_active").notNull().default("true"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertOpportunitySchema = createInsertSchema(opportunities).omit({
  id: true,
  createdAt: true,
});

export type InsertOpportunity = z.infer<typeof insertOpportunitySchema>;
export type Opportunity = typeof opportunities.$inferSelect;

// Sales tracking with 6-level comp model
export const sales = pgTable("sales", {
  id: serial("id").primaryKey(),
  opportunityId: integer("opportunity_id").references(() => opportunities.id),
  affiliateId: integer("affiliate_id").references(() => vltAffiliates.id),
  clientName: text("client_name").notNull(),
  clientEmail: text("client_email"),
  clientPhone: text("client_phone"),
  saleAmount: integer("sale_amount").notNull(), // cents
  status: text("status").notNull().default("pending"), // pending, approved, paid, cancelled
  referredByL1: integer("referred_by_l1"), // Top producer (67%)
  referredByL2: integer("referred_by_l2"), // Closest upline (3.5%)
  referredByL3: integer("referred_by_l3"), // 2.0%
  referredByL4: integer("referred_by_l4"), // 1.2%
  referredByL5: integer("referred_by_l5"), // 0.8%
  referredByL6: integer("referred_by_l6"), // Company (0.5% + compression)
  referredByL7: integer("referred_by_l7"), // Legacy - kept for backward compatibility
  recruiterId: integer("recruiter_id"), // For 2.5% bounty
  recruiterBounty: integer("recruiter_bounty").default(0), // cents
  l2Active: text("l2_active").default("true"), // For compression
  l3Active: text("l3_active").default("true"),
  l4Active: text("l4_active").default("true"),
  l5Active: text("l5_active").default("true"),
  compressedToL6: integer("compressed_to_l6").default(0), // Amount compressed to company
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertSaleSchema = createInsertSchema(sales).omit({
  id: true,
  status: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertSale = z.infer<typeof insertSaleSchema>;
export type Sale = typeof sales.$inferSelect;

// Commission payouts
export const commissions = pgTable("commissions", {
  id: serial("id").primaryKey(),
  saleId: integer("sale_id").references(() => sales.id),
  affiliateId: integer("affiliate_id").references(() => vltAffiliates.id),
  level: integer("level").notNull(), // 1-7
  amount: integer("amount").notNull(), // cents
  status: text("status").notNull().default("pending"), // pending, approved, paid
  paidAt: timestamp("paid_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertCommissionSchema = createInsertSchema(commissions).omit({
  id: true,
  status: true,
  paidAt: true,
  createdAt: true,
});

export type InsertCommission = z.infer<typeof insertCommissionSchema>;
export type Commission = typeof commissions.$inferSelect;

// Veteran intake for various programs
export const veteranIntake = pgTable("veteran_intake", {
  id: serial("id").primaryKey(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone"),
  branch: text("branch"),
  serviceStatus: text("service_status"), // active, veteran, reserve, guard
  programType: text("program_type").notNull(), // disability, holistic, healthcare, sales_opportunity
  currentRating: text("current_rating"), // For disability assistance
  desiredRating: text("desired_rating"),
  healthInterests: text("health_interests"), // For holistic/healthcare
  salesInterest: text("sales_interest"), // For sales opportunities
  additionalInfo: text("additional_info"),
  referralCode: text("referral_code"),
  referredByL1: integer("referred_by_l1"),
  referredByL2: integer("referred_by_l2"),
  referredByL3: integer("referred_by_l3"),
  referredByL4: integer("referred_by_l4"),
  referredByL5: integer("referred_by_l5"),
  referredByL6: integer("referred_by_l6"),
  referredByL7: integer("referred_by_l7"),
  status: text("status").notNull().default("new"),
  assignedTo: integer("assigned_to"),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertVeteranIntakeSchema = createInsertSchema(veteranIntake).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  referredByL1: true,
  referredByL2: true,
  referredByL3: true,
  referredByL4: true,
  referredByL5: true,
  referredByL6: true,
  referredByL7: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertVeteranIntake = z.infer<typeof insertVeteranIntakeSchema>;
export type VeteranIntake = typeof veteranIntake.$inferSelect;

// Business intake for B2B services
export const businessIntake = pgTable("business_intake", {
  id: serial("id").primaryKey(),
  businessName: text("business_name").notNull(),
  contactName: text("contact_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone"),
  businessType: text("business_type"), // llc, s_corp, c_corp, sole_prop, partnership
  industry: text("industry"),
  annualRevenue: text("annual_revenue"),
  employeeCount: text("employee_count"),
  serviceType: text("service_type").notNull(), // insurance, tax_credits, payroll, accounting, other
  serviceDetails: text("service_details"),
  isVeteranOwned: text("is_veteran_owned"),
  referralCode: text("referral_code"),
  referredByL1: integer("referred_by_l1"),
  referredByL2: integer("referred_by_l2"),
  referredByL3: integer("referred_by_l3"),
  referredByL4: integer("referred_by_l4"),
  referredByL5: integer("referred_by_l5"),
  referredByL6: integer("referred_by_l6"),
  referredByL7: integer("referred_by_l7"),
  status: text("status").notNull().default("new"),
  assignedTo: integer("assigned_to"),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertBusinessIntakeSchema = createInsertSchema(businessIntake).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  referredByL1: true,
  referredByL2: true,
  referredByL3: true,
  referredByL4: true,
  referredByL5: true,
  referredByL6: true,
  referredByL7: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertBusinessIntake = z.infer<typeof insertBusinessIntakeSchema>;
export type BusinessIntake = typeof businessIntake.$inferSelect;

export const insertVltAffiliateSchema = createInsertSchema(vltAffiliates).omit({
  id: true,
  totalLeads: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertVltAffiliate = z.infer<typeof insertVltAffiliateSchema>;
export type VltAffiliate = typeof vltAffiliates.$inferSelect;

// VLT Tax Intake Submissions
export const vltIntake = pgTable("vlt_intake", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull(),
  phone: text("phone"),
  issue: text("issue").notNull(), // credits, resolution, preparation, planning, payroll, other
  issueDetails: text("issue_details"),
  businessType: text("business_type"), // individual, sole_prop, llc, s_corp, c_corp, partnership
  businessName: text("business_name"),
  annualRevenue: text("annual_revenue"),
  isVeteran: text("is_veteran"),
  leadType: text("lead_type").default("direct_client"), // affiliate_referral, direct_client
  referrerName: text("referrer_name"), // For affiliate referrals
  referrerEmail: text("referrer_email"),
  referrerPhone: text("referrer_phone"),
  routedTo: text("routed_to"), // CPA, Tax Attorney, General
  status: text("status").notNull().default("new"), // new, contacted, in_progress, closed, converted
  assignedTo: integer("assigned_to"),
  notes: text("notes"),
  referralCode: text("referral_code"), // Affiliate referral code
  referredByL1: integer("referred_by_l1"), // Level 1 affiliate who referred
  referredByL2: integer("referred_by_l2"), // Level 2 upline
  referredByL3: integer("referred_by_l3"), // Level 3 upline
  referredByL4: integer("referred_by_l4"), // Level 4 upline
  referredByL5: integer("referred_by_l5"), // Level 5 upline
  referredByL6: integer("referred_by_l6"), // Level 6 upline (master)
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertVltIntakeSchema = createInsertSchema(vltIntake).omit({
  id: true,
  routedTo: true,
  status: true,
  assignedTo: true,
  notes: true,
  referredByL1: true,
  referredByL2: true,
  referredByL3: true,
  referredByL4: true,
  referredByL5: true,
  referredByL6: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertVltIntake = z.infer<typeof insertVltIntakeSchema>;
export type VltIntake = typeof vltIntake.$inferSelect;

// Contract templates for e-signature
export const contractTemplates = pgTable("contract_templates", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(), // e.g., "MAH Independent Representative Agreement"
  version: text("version").notNull().default("1.0"),
  content: text("content").notNull(), // Full contract text in markdown/HTML
  companyName: text("company_name").notNull(), // MISSION ACT HEALTH, INC.
  requiredFor: text("required_for").notNull().default("all"), // all, affiliate, sub_master, master
  isActive: text("is_active").notNull().default("true"),
  contractType: text("contract_type").notNull().default("general"), // general, service
  grossCommissionPct: integer("gross_commission_pct"), // e.g., 18 for 18% (for service contracts)
  serviceName: text("service_name"), // e.g., "ICC Logistics"
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertContractTemplateSchema = createInsertSchema(contractTemplates).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertContractTemplate = z.infer<typeof insertContractTemplateSchema>;
export type ContractTemplate = typeof contractTemplates.$inferSelect;

// Signed agreements tracking
export const signedAgreements = pgTable("signed_agreements", {
  id: serial("id").primaryKey(),
  contractTemplateId: integer("contract_template_id").references(() => contractTemplates.id).notNull(),
  affiliateId: integer("affiliate_id").notNull(), // User ID (not FK - can be user or VLT affiliate)
  userId: integer("user_id").references(() => users.id), // Link to regular user account
  affiliateName: text("affiliate_name").notNull(),
  affiliateEmail: text("affiliate_email").notNull(),
  signatureData: text("signature_data"), // Base64 signature image
  signedIpAddress: text("signed_ip_address"),
  agreedToTerms: text("agreed_to_terms").notNull().default("true"),
  physicalAddress: text("physical_address"),
  businessActivities: text("business_activities"),
  achName: text("ach_name"),
  achBank: text("ach_bank"),
  achAccountNumber: text("ach_account_number"),
  achRoutingNumber: text("ach_routing_number"),
  recruitedBy: text("recruited_by"),
  status: text("status").notNull().default("signed"), // signed, void, superseded
  signedAt: timestamp("signed_at").defaultNow().notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertSignedAgreementSchema = createInsertSchema(signedAgreements).omit({
  id: true,
  status: true,
  signedAt: true,
  createdAt: true,
});

export type InsertSignedAgreement = z.infer<typeof insertSignedAgreementSchema>;
export type SignedAgreement = typeof signedAgreements.$inferSelect;

// Commission configuration - simplified formula
// Producer: 69% base + compression from empty uplines (1% each, max 6 uplines)
// Each upline: 1% each
// House: 22.5% always
// Recruiter: 2.5% separate bounty
export const commissionConfig = pgTable("commission_config", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().default("default"),
  producerBasePct: integer("producer_base_pct").notNull().default(6900), // 69% = 6900 (x100)
  uplinePctEach: integer("upline_pct_each").notNull().default(100), // 1% = 100 per upline
  maxUplineLevels: integer("max_upline_levels").notNull().default(6), // max 6 uplines
  housePct: integer("house_pct").notNull().default(2250), // 22.5% = 2250
  recruiterBountyPct: integer("recruiter_bounty_pct").notNull().default(250), // 2.5% = 250
  isActive: text("is_active").notNull().default("true"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertCommissionConfigSchema = createInsertSchema(commissionConfig).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertCommissionConfig = z.infer<typeof insertCommissionConfigSchema>;
export type CommissionConfig = typeof commissionConfig.$inferSelect;

// Affiliate NDA - Simple good-faith agreement with Navigator USA Corp 501(c)(3)
export const affiliateNda = pgTable("affiliate_nda", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  fullName: text("full_name").notNull(),
  veteranNumber: text("veteran_number"),
  address: text("address").notNull(),
  customReferralCode: text("custom_referral_code"),
  signatureData: text("signature_data"),
  facePhoto: text("face_photo"), // Base64 webcam capture of face
  idPhoto: text("id_photo"), // Base64 uploaded ID document
  signedIpAddress: text("signed_ip_address"),
  agreedToTerms: text("agreed_to_terms").notNull().default("true"),
  signedAt: timestamp("signed_at").defaultNow().notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertAffiliateNdaSchema = createInsertSchema(affiliateNda).omit({
  id: true,
  signedAt: true,
  createdAt: true,
});

export type InsertAffiliateNda = z.infer<typeof insertAffiliateNdaSchema>;
export type AffiliateNda = typeof affiliateNda.$inferSelect;

// Business Leads - Submissions from the Vet Biz Owner page
export const businessLeads = pgTable("business_leads", {
  id: serial("id").primaryKey(),
  leadType: text("lead_type").notNull(), // "access_talent", "utilize_service", "promote_network"
  businessName: text("business_name").notNull(),
  contactName: text("contact_name").notNull(),
  position: text("position").notNull(),
  phone: text("phone").notNull(),
  email: text("email").notNull(),
  comment: text("comment"),
  status: text("status").notNull().default("new"), // new, contacted, in_progress, closed
  assignedTo: integer("assigned_to").references(() => users.id),
  referredBy: integer("referred_by").references(() => users.id),
  referralCode: text("referral_code"),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertBusinessLeadSchema = createInsertSchema(businessLeads).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertBusinessLead = z.infer<typeof insertBusinessLeadSchema>;
export type BusinessLead = typeof businessLeads.$inferSelect;

// IP Referral Tracking - tracks IP addresses linked to affiliates for 30 days
export const ipReferralTracking = pgTable("ip_referral_tracking", {
  id: serial("id").primaryKey(),
  ipAddress: text("ip_address").notNull(),
  affiliateId: integer("affiliate_id").references(() => users.id),
  referralCode: text("referral_code").notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertIpReferralTrackingSchema = createInsertSchema(ipReferralTracking).omit({
  id: true,
  createdAt: true,
});

export type InsertIpReferralTracking = z.infer<typeof insertIpReferralTrackingSchema>;
export type IpReferralTracking = typeof ipReferralTracking.$inferSelect;

// W9 Tax Forms - Affiliate tax information for 1099 reporting
export const affiliateW9 = pgTable("affiliate_w9", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  name: text("name").notNull(),
  businessName: text("business_name"),
  taxClassification: text("tax_classification").notNull().default("individual"), // individual, c_corp, s_corp, partnership, trust, llc
  address: text("address").notNull(),
  city: text("city").notNull(),
  state: text("state").notNull(),
  zip: text("zip").notNull(),
  ssn: text("ssn"), // Encrypted - Social Security Number (last 4 only stored)
  ein: text("ein"), // Employer Identification Number
  signatureData: text("signature_data"), // Base64 signature image
  signedIpAddress: text("signed_ip_address"),
  certificationDate: timestamp("certification_date").defaultNow().notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertAffiliateW9Schema = createInsertSchema(affiliateW9).omit({
  id: true,
  certificationDate: true,
  createdAt: true,
});

export type InsertAffiliateW9 = z.infer<typeof insertAffiliateW9Schema>;
export type AffiliateW9 = typeof affiliateW9.$inferSelect;

// Fin-Ops Partner Referral Tracking
export const finopsReferrals = pgTable("finops_referrals", {
  id: serial("id").primaryKey(),
  affiliateId: integer("affiliate_id").references(() => users.id),
  referralCode: text("referral_code"),
  partnerType: text("partner_type").notNull(), // my_locker, merchant_services, vgift_cards
  externalUrl: text("external_url").notNull(),
  visitorIp: text("visitor_ip"),
  userAgent: text("user_agent"),
  status: text("status").notNull().default("clicked"), // clicked, registered, converted
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertFinopsReferralSchema = createInsertSchema(finopsReferrals).omit({
  id: true,
  status: true,
  createdAt: true,
});

export type InsertFinopsReferral = z.infer<typeof insertFinopsReferralSchema>;
export type FinopsReferral = typeof finopsReferrals.$inferSelect;

// Disability Referrals - Tracking intakes from disability rating pages
export const disabilityReferrals = pgTable("disability_referrals", {
  id: serial("id").primaryKey(),
  // Affiliate tracking
  affiliateId: integer("affiliate_id").references(() => users.id),
  referralCode: text("referral_code"),
  // Claim type
  claimType: text("claim_type").notNull(), // initial, increase, denial, ssdi, widow
  // Veteran/applicant info
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  // Veteran details
  veteranStatus: text("veteran_status"), // veteran, spouse, dependent
  branchOfService: text("branch_of_service"),
  dischargeStatus: text("discharge_status"),
  currentRating: text("current_rating"), // 0-100% or "none"
  // Case details
  conditions: text("conditions"), // List of conditions
  caseDescription: text("case_description"),
  hasDocumentation: text("has_documentation"), // yes, no, partial
  // Contact preferences
  bestTimeToCall: text("best_time_to_call"),
  preferredContact: text("preferred_contact"), // phone, email, text
  // Status tracking
  status: text("status").notNull().default("new"), // new, contacted, in_progress, assigned, closed
  assignedTo: integer("assigned_to").references(() => users.id),
  notes: text("notes"),
  // Metadata
  visitorIp: text("visitor_ip"),
  userAgent: text("user_agent"),
  sourcePage: text("source_page"), // Which page they came from
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertDisabilityReferralSchema = createInsertSchema(disabilityReferrals).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertDisabilityReferral = z.infer<typeof insertDisabilityReferralSchema>;
export type DisabilityReferral = typeof disabilityReferrals.$inferSelect;

// Job Placement Intakes - for affiliates and veterans seeking job opportunities
export const jobPlacementIntakes = pgTable("job_placement_intakes", {
  id: serial("id").primaryKey(),
  // Affiliate tracking
  affiliateId: integer("affiliate_id").references(() => users.id),
  referralCode: text("referral_code"),
  // Intake type
  intakeType: text("intake_type").notNull(), // job_seeker, business_referral, business_services
  // Personal info
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  // Veteran status (for job seekers)
  isVeteran: text("is_veteran"), // yes, no
  branchOfService: text("branch_of_service"),
  // Industries or services selected (stored as JSON)
  industriesSelected: text("industries_selected").notNull(), // JSON array of selected industries (job_seeker/business_referral) or services (business_services)
  // Business info (for business referrals)
  businessName: text("business_name"),
  businessType: text("business_type"),
  businessWebsite: text("business_website"),
  hiringNeeds: text("hiring_needs"),
  // Additional info
  experience: text("experience"),
  preferredLocation: text("preferred_location"),
  additionalNotes: text("additional_notes"),
  // Status tracking
  status: text("status").notNull().default("new"), // new, contacted, in_progress, placed, closed
  assignedTo: integer("assigned_to").references(() => users.id),
  notes: text("notes"),
  // Metadata
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertJobPlacementIntakeSchema = createInsertSchema(jobPlacementIntakes).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertJobPlacementIntake = z.infer<typeof insertJobPlacementIntakeSchema>;
export type JobPlacementIntake = typeof jobPlacementIntakes.$inferSelect;

// Vet Professionals Intakes
export const vetProfessionalIntakes = pgTable("vet_professional_intakes", {
  id: serial("id").primaryKey(),
  // Affiliate tracking
  affiliateId: integer("affiliate_id").references(() => users.id),
  referralCode: text("referral_code"),
  // Profession type
  professionType: text("profession_type").notNull(), // attorneys, insurance, cpa, doctors
  // Personal info
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  // Veteran status
  isVeteran: text("is_veteran"),
  branchOfService: text("branch_of_service"),
  // Business info
  businessName: text("business_name"),
  businessType: text("business_type"),
  licenseNumber: text("license_number"),
  yearsExperience: text("years_experience"),
  specializations: text("specializations"),
  serviceArea: text("service_area"),
  // Additional
  additionalNotes: text("additional_notes"),
  // Admin fields
  status: text("status").notNull().default("new"),
  assignedTo: integer("assigned_to").references(() => users.id),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertVetProfessionalIntakeSchema = createInsertSchema(vetProfessionalIntakes).omit({
  id: true,
  status: true,
  assignedTo: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertVetProfessionalIntake = z.infer<typeof insertVetProfessionalIntakeSchema>;
export type VetProfessionalIntake = typeof vetProfessionalIntakes.$inferSelect;

// Healthcare Intakes - for veterans seeking treatment info/services
export const healthcareIntakes = pgTable("healthcare_intakes", {
  id: serial("id").primaryKey(),
  referralCode: text("referral_code"),
  // Treatment category
  category: text("category").notNull(), // ptsd, exosomes, less_invasive, new_treatments, guidance
  // Personal info
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  // Veteran info
  branchOfService: text("branch_of_service"),
  yearsOfService: text("years_of_service"),
  currentVaRating: text("current_va_rating"),
  // Healthcare needs
  currentConditions: text("current_conditions"),
  treatmentHistory: text("treatment_history"),
  treatmentGoals: text("treatment_goals"),
  preferredLocation: text("preferred_location"),
  insuranceType: text("insurance_type"),
  additionalNotes: text("additional_notes"),
  // Provider offering services
  isOfferingServices: boolean("is_offering_services").default(false),
  providerType: text("provider_type"), // If offering services
  providerCredentials: text("provider_credentials"),
  // Status tracking
  status: text("status").notNull().default("new"),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertHealthcareIntakeSchema = createInsertSchema(healthcareIntakes).omit({
  id: true,
  status: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertHealthcareIntake = z.infer<typeof insertHealthcareIntakeSchema>;
export type HealthcareIntake = typeof healthcareIntakes.$inferSelect;

// Schedule A Signatures - Track affiliate acknowledgment of commission structure
export const scheduleASignatures = pgTable("schedule_a_signatures", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  affiliateName: text("affiliate_name").notNull(),
  affiliateEmail: text("affiliate_email").notNull(),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  acknowledgedUplineCount: integer("acknowledged_upline_count").notNull().default(0),
  version: text("version").notNull().default("1.0"),
  signedAt: timestamp("signed_at").defaultNow().notNull(),
});

export const insertScheduleASignatureSchema = createInsertSchema(scheduleASignatures).omit({
  id: true,
  signedAt: true,
});

export type InsertScheduleASignature = z.infer<typeof insertScheduleASignatureSchema>;
export type ScheduleASignature = typeof scheduleASignatures.$inferSelect;

// Insurance Intakes - Track insurance inquiries
export const insuranceIntakes = pgTable("insurance_intakes", {
  id: serial("id").primaryKey(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  userType: text("user_type").notNull(), // consumer, business, insurance_agent
  intentType: text("intent_type").notNull(), // buy, sell, refer
  insuranceTypes: text("insurance_types").notNull(), // comma-separated: life, disability, health, business, auto, home
  businessName: text("business_name"),
  employeeCount: text("employee_count"),
  currentProvider: text("current_provider"),
  additionalInfo: text("additional_info"),
  referralCode: text("referral_code"),
  referredBy: integer("referred_by").references(() => users.id),
  status: text("status").notNull().default("new"), // new, contacted, quoted, closed_won, closed_lost
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertInsuranceIntakeSchema = createInsertSchema(insuranceIntakes).omit({
  id: true,
  status: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertInsuranceIntake = z.infer<typeof insertInsuranceIntakeSchema>;
export type InsuranceIntake = typeof insuranceIntakes.$inferSelect;

// Medical Sales Intakes - Track medical equipment/device sales leads
export const medicalSalesIntakes = pgTable("medical_sales_intakes", {
  id: serial("id").primaryKey(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  companyName: text("company_name"),
  roleType: text("role_type").notNull(), // buyer, seller, referrer
  productCategory: text("product_category").notNull(), // medical_devices, pharmaceuticals, equipment, supplies, other
  description: text("description"),
  referralCode: text("referral_code"),
  referredBy: integer("referred_by").references(() => users.id),
  assignedTo: integer("assigned_to").references(() => users.id),
  status: text("status").notNull().default("new"),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertMedicalSalesIntakeSchema = createInsertSchema(medicalSalesIntakes).omit({
  id: true,
  assignedTo: true,
  status: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertMedicalSalesIntake = z.infer<typeof insertMedicalSalesIntakeSchema>;
export type MedicalSalesIntake = typeof medicalSalesIntakes.$inferSelect;

// Business Development Intakes - Track business development leads
export const businessDevIntakes = pgTable("business_dev_intakes", {
  id: serial("id").primaryKey(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  companyName: text("company_name"),
  industry: text("industry").notNull(),
  serviceInterest: text("service_interest").notNull(), // consulting, partnerships, vendor_relations, lead_gen, other
  businessSize: text("business_size"), // small, medium, enterprise
  description: text("description"),
  referralCode: text("referral_code"),
  referredBy: integer("referred_by").references(() => users.id),
  assignedTo: integer("assigned_to").references(() => users.id),
  status: text("status").notNull().default("new"),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertBusinessDevIntakeSchema = createInsertSchema(businessDevIntakes).omit({
  id: true,
  assignedTo: true,
  status: true,
  notes: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertBusinessDevIntake = z.infer<typeof insertBusinessDevIntakeSchema>;
export type BusinessDevIntake = typeof businessDevIntakes.$inferSelect;
